<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2022-03-28T15:52:52.063Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>apache kafka 란?</title>
    <link href="http://KKimSangHeon.github.io/2022/03/24/kafka1/"/>
    <id>http://KKimSangHeon.github.io/2022/03/24/kafka1/</id>
    <published>2022-03-24T00:29:41.000Z</published>
    <updated>2022-03-28T15:52:52.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="핵심개념들"><a href="#핵심개념들" class="headerlink" title="핵심개념들"></a>핵심개념들</h3><p>카프카 ,  Producer, Consumer, Consumer Group, Topic, Partition, Segment, Broker, zookeeper, Quorum 알고리즘기반, __consumer_offsets, Broker replica, ISR, OSR, Controller, fetch의 흐름</p><h2 id="카프카"><a href="#카프카" class="headerlink" title="카프카?"></a>카프카?</h2><p>움직이는 데이터를 처리하는 플랫폼<br>카프카는 이벤트 스트리밍 플랫폼 - 흐르는 데이터를 처리하기 위한 플랫폼<br>LinkedIn 내에서 개발<br>기존의 Messaging Platform(예, MQ)로 이벤트 스트림이처리 불가능하여 이벤트 스트림 처리를 위해 개발</p><p>카프카는 이벤트 스트림을 안전하게 전송(Publish &amp; Subscribe)<br>이벤트 스트림을 디스크에 저장(write to disk)<br>이벤트 스트림을 분석 및 처리(processing &amp; ananlysis)</p><h3 id="이벤트"><a href="#이벤트" class="headerlink" title="이벤트?"></a>이벤트?</h3><p>Event는 비즈니스에서 일어나는 모든 일(데이터)을 의미<br>Event Stream은 연속적인 많은 이벤트들의 흐름을 의미</p><ol><li>이벤트 스트림을 안전하게 전송 &#x2F; Publish &amp; Subscribe</li><li>이벤트 스트림을 디스크에 안전하게 저장 &#x2F; Write to Disk(중요)</li><li>실시간 이벤트 스트림을 분석 및 처리 &#x2F; Processing &amp; Ananlysis</li></ol><p>Event(메시지&#x2F;데이터)가사용되는모든곳에서사용<br>o Messaging System<br>o IOT디바이스로부터데이터수집<br>o Realtime Event Stream Processing (Fraud Detection, 이상감지등)<br>o 애플리케이션에서 발생하는 로그수집<br>o DB동기화(MSA 기반의분리된DB간동기화)<br>o 실시간ETL<br>o Spark, Flink, Storm, Hadoop 과같은빅데이터기술과같이사용</p><h3 id="Producer-Consumer-Consumer-Group"><a href="#Producer-Consumer-Consumer-Group" class="headerlink" title="Producer, Consumer, Consumer Group"></a>Producer, Consumer, Consumer Group</h3><p>• Producer : 메시지를생산(Produce)해서 Kafka의Topic으로메시지를 보내는애플리케이션<br>• Consumer : Topic의메시지를가져와서소비(Consume)하는 애플리케이션<br>• Consumer Group : Topic의메시지를사용하기위해협력하는 Consumer들의집합<br>• 하나의Consumer는하나의Consumer Group에포함되며, Consumer Group내의Consumer들은협력하여Topic의메시지를 분산병렬처리함</p><p>Producer가Write하는LOG-END-OFFSET과Consumer Group의Consumer가Read하고<br>처리한후에Commit한CURRENT-OFFSET과의차이(Consumer Lag)가발생할수있음</p><h3 id="Topic-Partition-Segment"><a href="#Topic-Partition-Segment" class="headerlink" title="Topic, Partition, Segment"></a>Topic, Partition, Segment</h3><p>Topic : Kafka안에서메시지가저장되는장소, 논리적인표현<br>Partition : Commit Log, 하나의Topic은 하나 이상의Partition으로구성 병렬처리(Throughput향상)를 위해서 다수의Partition 사용. 파티션은 브로커들에 분산되어 저장된다.<br>Segment : 메시지(데이터)가저장되는실제물리File Segment File이 지정된 크기보다크거나 지정된 기간보다 오래되면 새파일이 열리고 메시지는새파일에추가됨</p><p>Topic생성시Partition개수를지정 개수변경가능하나운영시에는변경권장하지않음<br>Topic내의Partition들은서로독립적임<br>Event(Message)의순서는하나의Partition내에서만보장<br>Partition은Segment File들로구성됨<br>Rolling 정책: log.segment.bytes(default 1 GB), log.roll.hours(default 168 hours)</p><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p>Kafka Broker는Partition에대한Read및Write를관리하는소프트웨어</p><p>• Kafka Server라고부르기도함<br>• Topic내의Partition들을분산,유지및관리<br>• 각각의Broker들은ID로식별됨(단, ID는숫자)<br>• Topic의일부Partition들을포함<br>-&gt; Topic데이터의일부분(Partition)을갖을뿐데이터전체를갖고있지않음<br>• Kafka Cluster : 여러개의Broker들로구성됨<br>• Client는특정Broker에연결하면전체클러스터에연결됨<br>• 최소3대이상의Broker를하나의Cluster로구성해야함<br>-&gt; 4대이상을권장함</p><p>• Topic을구성하는Partition들은여러Broker 상에분산됨<br>• Topic생성시Kafka가자동으로Topic을구성하는전체 Partition들을모든Broker에게할당해주고분배해줌</p><p>모든 Kafka Broker는 Bootstrap(부트스트랩)서버라고부름<br>• 하나의Broker에만연결하면Cluster전체에연결됨<br>-&gt; 하지만,특정Broker장애를대비하여,전체Broker List(IP, port)를파라미터로입력권장<br>• 각각의Broker는모든Broker, Topic, Partition에대해알고있음(Metadata)</p><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p>Zookeeper는Broker를관리(Broker 들의목록&#x2F;설정을관리)하는소프트웨어<br>• Zookeeper는변경사항에대해Kafka에알림<br>-&gt;Topic 생성&#x2F;제거, Broker 추가&#x2F;제거등<br>• Zookeeper 없이는Kafka가작동할수없음<br>-&gt;KIP1)-500 을통해서Zookeeper제거가진행중<br>-&gt;2022년에Zookeeper를제거한정식버전출시예정중<br>• Zookeeper는홀수의서버로작동하게설계되어있음 (최소3, 권장5)<br>• Zookeeper에는Leader(writes)가있고나머지 서버는Follower(reads)</p><p>KIP : Kafka Improvement Proposal</p><p>Zookeeper는 분산형 Configuration 정보유지, 분산동기화서비스를제공하고대용량분산<br>시스템을위한네이밍레지스트리를제공하는소프트웨어<br>Leader, Follower로 구성되며 Floower는 Leader와 동기화하여 브로커에 전달한다.</p><p>분산작업을제어하기위한Tree형태의데이터저장소<br>-&gt; Zookeeper를사용하여멀티Kafka Broker들간의정보(변경사항포함)공유,동기화등을수행</p><h4 id="zookeeper는-Quorum-알고리즘기반"><a href="#zookeeper는-Quorum-알고리즘기반" class="headerlink" title="zookeeper는 Quorum 알고리즘기반"></a>zookeeper는 Quorum 알고리즘기반</h4><p>Quorum(쿼럼)은“정족수”이며, 합의체가의사를진행시키거나의결을하는데필요한최소한도의 인원수를뜻함<br>분산코디네이션환경에서예상치못한장애가발생해도분산시스템의일관성을유지시키기 위해서사용<br>Ensemble이3대로구성되었다면Quorum은2,즉Zookeeper 1대가장애가발생하더라도정상동작<br>Ensemble이5대로구성되었다면Quorum은3,즉Zookeeper 2대가장애가발생하더라도정상동작</p><p>3대를쓰나 4대를 쓰나 1개의 장애밖에 못버틴다(홀수를 권장하는 이유)</p><p>• Broker는Partition에대한Read및Write를관리하는소프트웨어<br>• Broker는Topic내의Partition들을분산,유지및관리<br>• 최소3대이상의Broker를하나의Cluster로구성해야함<br>-&gt; 4대이상을권장함<br>• Zookeeper는Broker를관리(Broker 들의목록&#x2F;설정을관리)하는소프트웨어<br>• Zookeeper는홀수의서버로작동하게설계되어있음(최소3, 권장5)</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>Message &#x3D;&#x3D; Record &#x3D;&#x3D; Event &#x3D;&#x3D; Data</p><p>레코드는 Header(Topic, Partition, Timestamp, etc), Key, Value로 구성된다.<br>Key와Value는Avro, JSON 등다양한형태가가능</p><p>Kafka는Record(데이터)를Byte Array로저장</p><p>흐름</p><ol><li>프로듀서에서 토픽을 send()</li><li>Serializer(String, avro, json ..등 다양함) 를 통해 byte array로 변환</li><li>Partitioner을 통해 어느파티션으로 보낼지 정해지고</li><li>Compress(사용유무 선택가능)</li><li>RecordAccumulator으로 보내져서 배치 혹은 건별로 카프카로 전송이 된다.</li><li>성공하면 metadata를 리턴하고 실패하면 retry</li></ol><p>개발자는 Serializer, Compress만 설정하고 send()메소드 정도만 호출하면 된다</p><p>Partitioner의역할<br>메시지를Topic의어떤Partition으로보낼지결정(Hash(Key) % Number of Partitions)</p><p>Key 가null일때처리<br>Kafka 2.4 이전 : DefaultPartitioner는 Round Robin정책으로동작. 여러 파티션에 하나씩 배정</p><p>Kafka 2.4이후: DefaultPartitioner는 Sticky정책으로동작. 하나의Batch가닫힐때까지 하나의partition에게record를 보내고랜덤으로Partition 선택.<br>배치처리가 더욱 효율적으로 이뤄짐</p><h3 id="Counsumer"><a href="#Counsumer" class="headerlink" title="Counsumer"></a>Counsumer</h3><p>Consumer Offset : Consumer Group이읽은위치를표시</p><p>• Consumer가자동이나수동으로데이터를읽은위치를commit하여다시읽음을방지<br>• __consumer_offsets 라는Internal Topic에서Consumer Offset을저장하여관리</p><p>4개의Partition으로구성된Topic의데이터를사용하는Single Consumer가있는경우,<br>이Consumer는Topic의모든Partition에서모든Record를Consume함</p><p>하나의Consumer는각Partition에서의<br>Consumer Offset을별도로유지(기록) 하면서모든Partition에서Consume함</p><p>• 4개의파티션이있는Topic를consume하는4개의Consumer가하나의Consumer Group에있다면,각Consumer는정확히하나의Partition에서Record를consume함<br>• Partition은항상Consumer Group내의하나의Consumer에의해서만사용됨<br>• Consumer는주어진Topic에서0개이상의많은Partition을사용할수있음</p><p>Partition이2 개이상인경우모든메시지에대한전체순서보장불가능<br>Partition을1개로구성하면모든메시지에서전체순서보장가능‒처리량저하<br>대부분의경우, Key로구분할수있는메시지들의순서보장이필요한경우가많음</p><p>운영중에Partition 개수를변경하면어떻게될까?<br>해쉬알고리즘은 파티션 갯수로 나누기 때문에 결국 순서보장이 불가능해짐</p><p>Key Cardinality는Consumer Group의개별Consumer가 수행하는작업의양에영향<br>적절히 잘 키를 선택해서 누군 놀고 누군 쉬는것이 일어나지 않도록 해야함<br>• Key선택이잘못되면작업부하가 고르지않을수있음<br>• Key는Integer, String등과같은 단순한유형일필요가없음<br>• Key는Value와마찬가지로Avro, JSON 등여러필드가있는복잡한객체일수있음<br>• 따라서, Partition전체에 Record를고르게배포하는Key를 만드는것이중요</p><p>Consumer Rebalancing<br>Consumer Group의다른Consumer가 실패한Consumer를대신함</p><h4 id="복제"><a href="#복제" class="headerlink" title="복제"></a>복제</h4><p>Broker에장애가발생하면어떻게될까?<br>장애가발생한Broker내의 Partition들은모두사용할수없게되는문제발생</p><p>다른Broker에서장애가발생한Partition을대신해서Partition을새로만들면장애를해결?<br>기존메시지는버릴것인가?기존Offset 정보들을버릴것인가?</p><p>Partition을복제(Replication)하여다른Broker상에서복제물(Replicas)을만들어서장애를 미리대비함</p><p>Replicas - Leader Partition, Follower Partition로 구성됨<br>Replication Factor &#x3D; 3이라 하면 Leader Partition 한개, Follower Partition 두개로 구성됨</p><p>Producer는Leader에만Write하고Consumer는Leader로부터만Read함(Apache Kafka 2.4부터 Follower 파티션에서 컨슈머가 Fetching(Read) 가능)<br>Follower는Broker장애시안정성을제공하기위해서만존재<br>Follower는Leader의Commit Log에서데이터를가져오기요청(Fetch Request)으로복제 - 팔로워가 리더한테 요청을 해서 가져가는 구조</p><p>Leader에장애가발생하면?<br>Kafka 클러스터는Follower중에서새로운Leader를선출 Clients(Producer&#x2F;Consumer)는자동으로새Leader로전환</p><p>하나의Broker에만Partition의Leader들이몰려있다면?<br>특정Broker에만Client(Producer&#x2F;Consumer)로인해부하집중(Hot Spot)</p><p>Hot Spot 방지<br>auto.leader.rebalance.enable : 기본값enable # 리더가 각 브로커 적절히 분배되도록 설정하는것.<br>leader.imbalance.check.interval.seconds : 기본값300 sec  # 30 초마다 리더가 적절히 분배되었는지 확인<br>leader.imbalance.per.broker.percentage : 기본값10 # 다른 브로커보다 10퍼센트 이상 많이가져가면 불균형이라 판단</p><p>Rack Awareness<br>Rack 간분산하여Rack 장애를대비<br>동일한Rack 혹은Available Zone상의Broker들에동일한“rack name” 지정<br>복제본(Replica-Leader&#x2F;Follower)은최대한Rack간에균형을유지하여Rack 장애대비<br>Topic 생성시또는Auto Data Balancer&#x2F;Self Balancing Cluster 동작때만실행</p><h3 id="In-Sync-Replicas-ISR-Leader-장애시Leader를선출하는데사용"><a href="#In-Sync-Replicas-ISR-Leader-장애시Leader를선출하는데사용" class="headerlink" title="In-Sync Replicas(ISR) : Leader 장애시Leader를선출하는데사용"></a>In-Sync Replicas(ISR) : Leader 장애시Leader를선출하는데사용</h3><p>In-Sync Replicas(ISR)는High Water Mark라고하는지점까지동일한Replicas (Leader와 Follower모두)의목록</p><p>Leader에장애가발생하면, ISR 중에서새Leader를선출</p><h3 id="ISR-replica-lag-max-messages"><a href="#ISR-replica-lag-max-messages" class="headerlink" title="ISR : replica.lag.max.messages"></a>ISR : replica.lag.max.messages</h3><p>replica.lag.max.messages&#x3D;4 - 리더가 갖고있는 LOG-END-OFFSET과 4 미만으로 차이나는 팔로워들을 ISR로 지정한다 4개 이상 차이나는 팔로워들을 Out-of-Sync Follower(OSR) 이라 한다,</p><p>High Water Mark: 4미만(replica.lag.max.messages&#x3D;4일 때)으로 차이나는 지점 중 하나로써 컨슈머가 거기까지 잘 복사해간것을 의미</p><h4 id="replica-lag-max-messages로ISR판단시나타날수있는문제점"><a href="#replica-lag-max-messages로ISR판단시나타날수있는문제점" class="headerlink" title="replica.lag.max.messages로ISR판단시나타날수있는문제점"></a>replica.lag.max.messages로ISR판단시나타날수있는문제점</h4><p>• 메시지유입량이갑자기늘어날경우(예,초당10 msg&#x2F;sec),지연으로판단하고OSR(Outof-<br>Sync Replica)로상태를변경시킴<br>• 메시지가항상일정한비율(초당유입되는메시지, 3 msg&#x2F;sec 이하)로Kafka로들어올<br>때, replica.lag.max.messages&#x3D;5로하면5개이상으로지연되는경우가없으므로 ISR들이정상적으로동작<br>• 실제Follower는정상적으로동작하고단지잠깐지연만발생했을뿐인데, replica.lag.max.messages옵션을이용하면OSR로판단하게되는문제가발생(운영중에 불필요한error 발생및그로인한불필요한retry 유발)</p><h3 id="ISR-replica-lag-time-max-ms으로판단해야함"><a href="#ISR-replica-lag-time-max-ms으로판단해야함" class="headerlink" title="ISR : replica.lag.time.max.ms으로판단해야함"></a>ISR : replica.lag.time.max.ms으로판단해야함</h3><p>• Follower가Leader로Fetch 요청을보내는Interval을체크<br>• 예) replica.lag.time.max.ms &#x3D; 10000이라면Follower가Leader로Fetch 요청을<br>10000 ms내에만요청하면정상으로판단<br>• Confluent 에서는replica.lag.time.max.ms옵션만제공(복잡성제거)</p><p>ISR은Leader(브로커)가관리<br>①Follower가너무느리면Leader는ISR에서Follower를제거하고ZooKeeper에ISR을유지<br>②Controller는Partition Metadata에대한변경사항에대해서Zookeeper로부터수신<br>(replica.lag.time.max.ms이내에 Follower가fetch하지않으면 ISR에서제거함)</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller ??"></a>Controller ??</h3><p>• Kafka Cluster내의Broker중하나가Controller가됨<br>• Controller는ZooKeeper를통해Broker Liveness를모니터링 , ISR 정보를 받아들임<br>• Controller는Leader와Replica 정보를Cluster내의다른Broker들에게전달<br>• Controller는ZooKeeper에Replicas정보의복사본을유지한다음더빠른액세스를<br>위해클러스터의모든Broker들에게동일한정보를캐시함<br>• Controller가Leader 장애시Leader Election을수행<br>• Controller가장애가나면다른Active Broker들중에서재선출됨(주키퍼가 함)</p><h3 id="Last-Committed-Offset-Current-Position-High-Water-Mark-Log-End-Offset"><a href="#Last-Committed-Offset-Current-Position-High-Water-Mark-Log-End-Offset" class="headerlink" title="Last Committed Offset, Current Position, High Water Mark, Log End Offset??"></a>Last Committed Offset, Current Position, High Water Mark, Log End Offset??</h3><p>• Last Committed Offset(Current Offset) : Consumer가최종Commit한Offset<br>• Current Position : Consumer가읽어간위치(처리중, Commit 전)<br>• High Water Mark(Committed &#x2F; Fully-Replicated Committed) : ISR(Leader-Follower)간에복제된Offset<br>• Log End Offset : Producer가메시지를보내서저장된,로그의맨끝Offset</p><h3 id="Committed의의미"><a href="#Committed의의미" class="headerlink" title="Committed의의미?"></a>Committed의의미?</h3><p>• ISR 목록의모든Replicas가메시지를성공적으로가져오면“Committed”. OSR에 있는건 신경쓰지 않음<br>• Consumer는Committed메시지만읽을수있음<br>• Leader는메시지를Commit할시기를결정<br>• Committed메시지는모든Follower에서 동일한Offset을갖도록보장(OSR이라 한들 언젠간 따라잡을테니)<br>• 즉, 어떤Replica가Leader인지에관계없이 (장애발생이라도) 모든Consumer는해당 Offset에서같은데이터를볼수있음<br>• Broker가다시시작할때Committed 메시지목록을유지하도록하기위해, Broker의모든Partition에대한마지막 Committed Offset은replicationoffset-checkpoint라는파일에기록됨</p><p>High Water Mark<br>• 가장최근에Committed메시지의Offset추적<br>• replication-offset-checkpoint 파일에체크포인트를기록</p><p>Leader Epoch<br>• 새Leader가선출된시점을Offset으로표시<br>• Broker복구중에메시지를체크포인트로자른다음현재Leader를따르기위해사용됨<br>• Controller가새Leader를선택하면Leader Epoch를업데이트하고해당정보를ISR 목록의모든구성원에게보냄<br>• leader-epoch-checkpoint 파일에체크포인트를기록<br>즉 새로운 리더에 대한 기록이라고 보면 될듯</p><h3 id="fetch의-흐름"><a href="#fetch의-흐름" class="headerlink" title="fetch의 흐름"></a>fetch의 흐름</h3><p>팔로워들은 패쳐쓰레드가 리더한테 페치(데이터를 가져와서)를 해서 자신의 파티션에 write를 함<br>팔로워의 패쳐 쓰레드가 fetch를 했는데 null 이 오는경우(더이상 데이터를 가져갈게 없는 최신의 상태)<br>Leader는 자신의 High Water Mark 이동한다.<br>그 이후 또 팔로워가 fetch를 리더한테 하면 Leader는High Water Mark를 던져주고 팔로워들 또한 High Water Mark를 갱신한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;핵심개념들&quot;&gt;&lt;a href=&quot;#핵심개념들&quot; class=&quot;headerlink&quot; title=&quot;핵심개념들&quot;&gt;&lt;/a&gt;핵심개념들&lt;/h3&gt;&lt;p&gt;카프카 ,  Producer, Consumer, Consumer Group, Topic, Partitio
      
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="오픈소스,기술" scheme="http://KKimSangHeon.github.io/categories/CS/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%88%A0/"/>
    
    
      <category term="Kafka" scheme="http://KKimSangHeon.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>spring security</title>
    <link href="http://KKimSangHeon.github.io/2022/03/24/spring-security/"/>
    <id>http://KKimSangHeon.github.io/2022/03/24/spring-security/</id>
    <published>2022-03-23T23:54:07.000Z</published>
    <updated>2022-03-28T16:08:06.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1부"><a href="#1부" class="headerlink" title="1부"></a>1부</h2><p>Principal principal는 아규먼트 리졸버로 받아서 처리된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/dashboard&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dashboard</span><span class="params">(Model model, Principal principal)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Hello &quot;</span> + principal.getName());</span><br><span class="line">    sampleService.dashboard();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;dashboard&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>의존성 추가</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>의존성을 추가하면 모든 요청은 인증을 필요로 해지고, 기본적으로 계정을 하나 만들어주는데 user&#x2F;{패스워드랜덤} 으로 만들어준다.</p><h3 id="11page"><a href="#11page" class="headerlink" title="11page"></a>11page</h3><p>AuthenticationManager를 빈으로 등록하는 이유는 다른 곳에서 사용하기 위함임.<br>기본적으론 빈으로 등록이 안된다고 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="12page-noop-123"><a href="#12page-noop-123" class="headerlink" title="12page {noop}123?"></a>12page {noop}123?</h3><p>앞에 {xxxx}는 인코딩 방식을 의미한다. {noop}는 평문으로 저장한것이다</p><p>UserDetailsService 를 implements한 service를 빈으로 등록해둘 경우 따로 WebSecurityConfigureAdapter를 상속하고 configure() 메소드에 아래처럼 세팅을 안해도 된다.<br>PasswordEncoder 또한 마찬가지</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  AccountService accountService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    auth.UserDetailsService(accountService);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14page"><a href="#14page" class="headerlink" title="14page"></a>14page</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>가짜 유저를 활용하여 테스트 코드를 작성하는법.<br>실제로 디비에 들어있다고 가정하는것이 아닌 해당 테스트 유저가 있다고 가정하고 특정 페이지에 접근시 어떤 응답이 발생하는지 확인하는데 사용됨</p><p>@WithUser 대신 @WithMockUser(username &#x3D; “keesun”, roles &#x3D; “USER”) 를 넣어도 되지만 반복을 줄이기 위해 어노테이션을 하나 생성한것임</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@WithMockUser(username = &quot;keesun&quot;, roles = &quot;USER&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WithUser &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithAnonymousUser</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">index_anonymous</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            .andDo(print())</span><br><span class="line">            .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithUser</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">index_user</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            .andDo(print())</span><br><span class="line">            .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithUser</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">admin_user</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/admin&quot;</span>))</span><br><span class="line">            .andDo(print())</span><br><span class="line">            .andExpect(status().isForbidden());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithMockUser(username = &quot;keesun&quot;, roles = &quot;ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">admin_admin</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/admin&quot;</span>))</span><br><span class="line">            .andDo(print())</span><br><span class="line">            .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>form 로그인을 활용하여 로그인하는 테스트코드를 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login_success</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;keesun&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.createUser(username, password);</span><br><span class="line">    mockMvc.perform(formLogin().user(user.getUsername()).password(password))</span><br><span class="line">            .andExpect(authenticated());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login_success2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;keesun&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.createUser(username, password);</span><br><span class="line">    mockMvc.perform(formLogin().user(user.getUsername()).password(password))</span><br><span class="line">            .andExpect(authenticated());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login_fail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;keesun&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.createUser(username, password);</span><br><span class="line">    mockMvc.perform(formLogin().user(user.getUsername()).password(<span class="string">&quot;12345&quot;</span>))</span><br><span class="line">            .andExpect(unauthenticated());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Account <span class="title function_">createUser</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    account.setUsername(username);</span><br><span class="line">    account.setPassword(password);</span><br><span class="line">    account.setRole(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> accountService.createNew(account);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2부"><a href="#2부" class="headerlink" title="2부"></a>2부</h2><h3 id="16page"><a href="#16page" class="headerlink" title="16page"></a>16page</h3><p>인증된 사용자 정보를 Principal라고 하는데 이를 Authentication객체에 담아서 보관하고 Authentication를 SecurityContext로 감싸고 SecurityContext를 SecurityContextHolder로 감싼다.</p><p>SecurityContextHolder</p><ul><li>SecurityContext 제공, 기본적으로 ThreadLocal을 사용한다.<br>(즉 Authentication을 한 쓰레드 안에서 사용가능(파라미터를 넘기지 않아도..))<br>ThreadLocal 대신 다른 전략을 활용할 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> accountRepository.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (account == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(username);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>.builder()</span><br><span class="line">                    .username(account.getUsername())</span><br><span class="line">                    .password(account.getPassword())</span><br><span class="line">                    .roles(account.getRole())</span><br><span class="line">                    .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dashboard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 리턴하는건 위에 User.builder()에서 생성된 UserDetails 타입이다.</span></span><br><span class="line">        <span class="comment">// UserDetails 는 애플리케이션이 가지고 있는 유저 정보와</span></span><br><span class="line">        <span class="comment">//스프링 시큐리티가 사용하는 Authentication 객체 사이의 어댑터이다.</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span>  authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// User.builder()에서 지정한 role가 들어가있음</span></span><br><span class="line">        Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = authentication.getAuthorities();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// null이 나옴</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">credentials</span> <span class="operator">=</span> authentication.getCredentials();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">authenticated</span> <span class="operator">=</span> authentication.isAuthenticated();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>###SecurityContextHolder, AuthenticationManager   18p<br>Authentication정보를 담고있는 SecurityContextHolder. 그리고 인증을 담당하는 AuthenticationManager</p><h3 id="인증을-하는-AuthenticationManager-ProviderManager를-보통-많이씀-의-흐름-인증-연관"><a href="#인증을-하는-AuthenticationManager-ProviderManager를-보통-많이씀-의-흐름-인증-연관" class="headerlink" title="인증을 하는 AuthenticationManager(ProviderManager를 보통 많이씀)의 흐름 (인증 연관)"></a>인증을 하는 AuthenticationManager(ProviderManager를 보통 많이씀)의 흐름 (인증 연관)</h3><p>스프링 시큐리티에서 인증(Authentication)은 AuthenticationManager가 한다.</p><p>AuthenticationManager인터페이스는 아래 메소드 하나만 갖는다.<br><code>Authentication authenticate(Authentication authentication) throws AuthenticationException;</code><br>인자로 받은 Authentication이 유효한 인증인지 확인하고 유효하다면 Authentication 객체를 리턴한다.<br>인자 Authentication는 사용자가 입력한 인증에 필요한 정보(username, password)로 만든 객체임. (폼 인증인 경우)<br>인증을 확인하는 과정에서 비활성 계정, 잘못된 비번, 잠긴 계정 등의 에러를 던질 수 있다.</p><p>AuthenticationManager 구현체로는 ProviderManager를 보통 많이쓴다.</p><p>인증이 들어오면 ProviderManager 의 authenticate() 메소드가 호출되는데<br>ProviderManager는 private List<AuthenticationProvider> providers; 를 갖고있는데 얘네들로 처리 가능한 인증인지 확인해보고 자신이 처리하지 못하는 인증일 경우  this.parent.authenticate(authentication); 를 통해 부모의 authenticate() 메소드를 호출한다.</p><p>인증이 가능한 providers를 갖고있는 ProviderManager에 가게되면 provider.authenticate() 메소드를 호출하게 되고</p><p>UserDetailsService를 사용했을 경우 AbstractUserDetailsAuthenticationProvider(추상클래스임) 로 들어가고  this.retrieveUser() 메소드를 호출하게 된다.</p><p>그 후 DaoAuthenticationProvider(AbstractUserDetailsAuthenticationProvider를 상속한클래스) 의 retrieveUser()로 들어오고  this.getUserDetailsService() 를 활용하는데 이는 위에서 만든 UserDetailsService를 implements한 AccountService이다.</p><p>그 후 DaoAuthenticationProvider를 빠져나와  AbstractUserDetailsAuthenticationProvider 안에서 this.preAuthenticationChecks.check(user);를 하는데 여기서 추가적인 체크를 진행한다. (계정잠금유무, 비활성 계정 등)</p><p>그 후 ProviderManager 안 authenticate() 에선 result라는 객체(Authentication타입)를 리턴하는데 얘는 곧 AuthenticationManager의 authenticate()메서드에서 리턴하는 객체이다.</p><p>result 안에 principal이라고 들어있는데 얘는 아까 위에서 loadUserByUsername() 메소드에서 리턴한 user객체가 들어있다.</p><p>또한 이 result(Authentication타입)가 SecurityContextHolder안에 들어가게 된다.</p><p><code>정리</code> : 인증을 담당하는 AuthenticationManager 인터페이스를 구현한 ProviderManager는 AuthenticationProvider를 리스트로 갖고이으며 갖고있는 리스트로 인증을 처리할 수 없을 경우 this.parent.authenticate(authentication); 메소드를 호출하여 부모의 리스트를 통해 인증을 진행한다. UserDetailsService를 사용했을 경우 AbstractUserDetailsAuthenticationProvider -&gt; DaoAuthenticationProvider 를 거치게 되고 retrieveUser()메소드가 호출되는데 여기선 UserDetailsService를 implements한 객체가 사용되며 loadUserByUsername() 메소드가 사용된다. 그 후  this.preAuthenticationChecks.check(user); 를 하는데 여기서 추가적인 체크를 진행한다. (계정잠금유무 등) 최종적으로 result라는 객체(Authentication타입)를 리턴하게 되고 result 안에 principal이라고 들어있는데 얘는 아까 위에서 loadUserByUsername() 메소드에서 리턴한 user객체가 들어있다. 또한 이 객체(result)는  SecurityContextHolder안에서 찾을 수 있다.</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>한 쓰레드안에서 변수를 공유</p><p>Java.lang 패키지에서 제공하는 쓰레드 범위 변수. 즉, 쓰레드 수준의 데이터 저장소.<br>●    같은 쓰레드 내에서만 공유.<br>●    따라서 같은 쓰레드라면 해당 데이터를 메소드 매개변수로 넘겨줄 필요 없음.<br>●    SecurityContextHolder의 기본 전략.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Account&gt; ACCOUNT_THREAD_LOCAL</span><br><span class="line">            = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setAccount</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        ACCOUNT_THREAD_LOCAL.set(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Account <span class="title function_">getAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ACCOUNT_THREAD_LOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="13-Authencation과-SecurityContextHolder-인증-연관"><a href="#13-Authencation과-SecurityContextHolder-인증-연관" class="headerlink" title="13.    Authencation과 SecurityContextHolder (인증 연관)"></a>13.    Authencation과 SecurityContextHolder (인증 연관)</h3><p>AuthenticationManager가 인증을 마친 뒤 리턴 받은 Authentication 객체의 행방은?<br>SecurityContextHolder에 Authencation이 언제들어가는지 확인해보자.</p><p>크게 UsernamePasswordAuthenticationFilter, SecurityContextPersisenceFilter 가  Authencation 객체를 SecurityContextHolder에 넣어준다.(위 예제의 경우)</p><p>UsernamePasswordAuthenticationFilter<br>●    폼 인증을 처리하는 시큐리티 필터<br>●    인증된 Authentication 객체를 SecurityContextHolder에 넣어주는 필터<br>●    SecurityContextHolder.getContext().setAuthentication(authentication)</p><p>SecurityContextPersistenceFilter<br>●    SecurityContext를 HTTP session에 캐시(기본 전략)하여 여러 요청에서 Authentication을 공유할 수 있게하는 필터.<br>●    SecurityContextRepository를 교체하여 세션을 HTTP session이 아닌 다른 곳에 저장하는 것도 가능하다.</p><p><code>로그인 전 상세흐름</code></p><p>처음 SecurityContextPersistenceFilter필터에 걸리는데 SecurityContextPersistenceFilter는 캐싱하고 있던 SecurityContext를 매 요청마다 복구하려 한다.<br><strong><code>SecurityContextPersistenceFilter.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> repo.loadContext(holder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그 후 UsernamePasswordAuthenticationFilter에 걸리게 되는데(폼 인증일 때)<br>AuthenticationManager 를 가져와 authenticate()를 실행한다. 이 때 ProviderManager를 통해 인증이 벌어진다.<br>즉 UsernamePasswordAuthenticationFilter가 AuthenticationManager(ProviderManager가 얘를 구현함)를 쓰는것임</p><p><strong><code>UsernamePasswordAuthenticationFilter.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br></pre></td></tr></table></figure><p>인증이 정상적으로 일어나게 되면 UsernamePasswordAuthenticationFilter 가 상속한 AbstractAuthenticationProcessingFilter로 가게 되고 AbstractAuthenticationProcessingFilter는 UsernamePasswordAuthenticationFilter의 attemptAuthentication() 메소드를 통해 얻은 인증결과인 authResult를 활용하여 successfulAuthentication() 메소드를 호출하고</p><p><strong><code>AbstractAuthenticationProcessingFilter.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">// attemptAuthentication는 추상메서드로써 UsernamePasswordAuthenticationFilter이 구현한걸 사용함</span></span><br><span class="line">    authResult = attemptAuthentication(request, response);    </span><br><span class="line">    successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>successfulAuthentication() 메소드를 따라가면 SecurityContextHolder에 인증을 넣는것을 볼 수 있다.</p><p><strong><code>AbstractAuthenticationProcessingFilter.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">    HttpServletResponse response, FilterChain chain, Authentication authResult)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>정리하자면 AbstractAuthenticationProcessingFilter는 템플릿 메소드 패턴이며  UsernamePasswordAuthenticationFilter은 attemptAuthentication()메소드를 구현한것이다.</p><p><code>로그인 후 상세흐름</code><br>SecurityContextPersistenceFilter가 먼저 받고 SecurityContextRepository(기본적인 실 구현체 HttpSessionSecurityContextRepository) 에서 SecurityContext를 가져오고 SecurityContextHolder 에 다시 넣어준다.</p><p><strong><code>SecurityContextPersistenceFilter.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SecurityContextRepository repo;</span><br><span class="line"></span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> repo.loadContext(holder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">      chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      SecurityContextHolder.clearContext();</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>즉 SecurityContextPersistenceFilter는 매 요청마다 SecurityContextHolder에 SecurityContext를 넣어주고 비우고를 반복한다.</p><p>총 15개정도의 필터가 있다고 한다..</p><h3 id="스프링-시큐리티-Filter와-FilterChainProxy"><a href="#스프링-시큐리티-Filter와-FilterChainProxy" class="headerlink" title="스프링 시큐리티 Filter와 FilterChainProxy"></a>스프링 시큐리티 Filter와 FilterChainProxy</h3><p>SecurityContextPersistenceFilter, UsernamePasswordAuthenticationFilter가 어디서 어떻게 호출 되는지 보자</p><p>FilterChainProxy에 getFilters()메소드가 있는데 urlpattern이 매치가 되면 매칭하는필터들을 가져오고 필터들을 순회하며 순차적으로 실행한다.<br>즉 filterChains중 하나의 chain에서 필터들을 찾아서 적용한다. (각 SecurityFilterChain은 여러개의 필터를 갖고있음)<br><strong><code>FilterChainProxy.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Filter&gt; <span class="title function_">getFilters</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chain.matches(request)) &#123;</span><br><span class="line">      <span class="keyword">return</span> chain.getFilters();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VirtualFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    currentPosition++;</span><br><span class="line">    <span class="type">Filter</span> <span class="variable">nextFilter</span> <span class="operator">=</span> additionalFilters.get(currentPosition - <span class="number">1</span>);</span><br><span class="line">    nextFilter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 getFilters() 에서 순회되는 filterChains(springSecurityFilterChain 리스트)는 내가 생성한 SecurityConfig(@configure가 붙어있고 WebSecurityConfigureAdapter를 상속한 애)가 된다. 즉 SecurityConfig가 여러개가 있으면 filterChains는 여러개가 됨.</p><blockquote><p>WebSecurity는  WebSecurityConfiguration 으로 만들어지며 WebSecurity를 활용하여 filterChainProxy를 만든다. 이 체인이 바로  DelegatingFilterProxy가 위임하는 체인 프록시이다. 또한 시큐리티 필터들도 WebSecurity가 만들게 된다,</p></blockquote><p>filterChains안에 필터들이 들어있다.</p><p>스프링 시큐리티가 제공하는 필터들</p><ol><li>WebAsyncManagerIntergrationFilter</li><li>SecurityContextPersistenceFilter</li><li>HeaderWriterFilter</li><li>CsrfFilter</li><li>LogoutFilter</li><li>UsernamePasswordAuthenticationFilter</li><li>DefaultLoginPageGeneratingFilter</li><li>DefaultLogoutPageGeneratingFilter</li><li>BasicAuthenticationFilter</li><li>RequestCacheAwareFtiler</li><li>SecurityContextHolderAwareReqeustFilter</li><li>AnonymouseAuthenticationFilter</li><li>SessionManagementFilter</li><li>ExeptionTranslationFilter</li><li>FilterSecurityInterceptor</li></ol><p>이 모든 필터는 FilterChainProxy가 갖고있으며 사용한다.(SecurityFilterChain 마다 갖고있는 필터가 다름)</p><h3 id="15-DelegatingFilterProxy와-FilterChainProxy"><a href="#15-DelegatingFilterProxy와-FilterChainProxy" class="headerlink" title="15.    DelegatingFilterProxy와 FilterChainProxy"></a>15.    DelegatingFilterProxy와 FilterChainProxy</h3><p>서블릿 필터 구현체중 하나인 DelegatingFilterProxy. 누군가에게 위임하는 프록시.<br>즉 자기가 직접 처리하지 않고 스프링 내 bean에게 위임함.<br>DelegatingFilterProxy가 FilterChainProxy를 호출하는것</p><p>DelegatingFilterProxy<br>●    일반적인 서블릿 필터.<br>●    서블릿 필터 처리를 스프링에 들어있는 빈으로 위임하고 싶을 때 사용하는 서블릿 필터.<br>●    타겟 빈 이름을 설정한다.<br>●    스프링 부트 없이 스프링 시큐리티 설정할 때는 AbstractSecurityWebApplicationInitializer를 사용해서 등록.<br>●    스프링 부트를 사용할 때는 자동으로 등록 된다. (SecurityFilterAutoConfiguration)</p><p>FilterChainProxy<br>●    보통 “springSecurityFilterChain” 이라는 이름의 빈으로 등록된다</p><p><code>스프링부트 사용시</code><br>DelegatingFilterProxy -&gt; SecurityFilterAutoConfiguration -&gt; FilterChainProxy -&gt; filter list 호출</p><h3 id="16-AccessDecisionManager-인가-연관"><a href="#16-AccessDecisionManager-인가-연관" class="headerlink" title="16.    AccessDecisionManager (인가 연관)"></a>16.    AccessDecisionManager (인가 연관)</h3><p><code>인가</code>를 할 땐 AccessDecisionManager (인터페이스임)를 쓴다.<br>AccessDecisionManager는 여러개의 AccessDecisionVoter(투표자)가 있다,</p><p>Access Control 결정을 내리는 인터페이스로, 구현체 3가지를 기본으로 제공한다.<br>●    AffirmativeBased: 여러 Voter중에 한명이라도 허용하면 허용. (디폴트)<br>●    ConsensusBased: 다수결<br>●    UnanimousBased: 만장일치</p><p>AccessDecisionVoter<br>●    해당 Authentication이 특정한 Object에 접근할 때 필요한 ConfigAttributes를 만족하는지 확인한다.<br>●    WebExpressionVoter: 웹 시큐리티에서 사용하는 기본 구현체, ROLE_Xxxx가 매치하는지 확인.<br>●    RoleHierarchyVoter: 계층형 ROLE 지원. ADMIN &gt; MANAGER &gt; USER</p><p>AffirmativeBased 를 보면 아래와같은것들이 있다. 투표를 진행하는 코드임. 하나라도 ACCESS_GRANTED이면 승인함<br><strong><code>AffirmativeBased.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AffirmativeBased</span> <span class="keyword">extends</span> <span class="title class_">AbstractAccessDecisionManager</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object,</span></span><br><span class="line"><span class="params">Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">deny</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> voter.vote(authentication, object, configAttributes);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">    <span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:</span><br><span class="line">      deny++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(messages.getMessage(</span><br><span class="line"><span class="string">&quot;AbstractAccessDecisionManager.accessDenied&quot;</span>, <span class="string">&quot;Access is denied&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>admin은 일반 user권한 페이지 또한 접근이 가능해야한다. 이를 위해 아래처럼 수정해보자.<br>roleHierarchy 를 등록하기 위해 아래절차를 거치는것임. roleHierarchy 를 추가한것 외엔 기존 AffirmativeBased 디폴트 설정과 동일하게 쓰는것임</p><blockquote><p>위에서 말했듯이 AccessDecisionManager를 등록해놓지 않으면 기본적으로 AffirmativeBased를 쓰게 된다.</p></blockquote><p><strong><code>SecurityConfig.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> AccessDecisionManager <span class="title function_">accessDecisionManager</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">RoleHierarchyImpl</span> <span class="variable">roleHierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">  roleHierarchy.setHierarchy(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_USER&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">DefaultWebSecurityExpressionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityExpressionHandler</span>();</span><br><span class="line">  handler.setRoleHierarchy(roleHierarchy);</span><br><span class="line"></span><br><span class="line">  <span class="type">WebExpressionVoter</span> <span class="variable">webExpressionVoter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebExpressionVoter</span>();</span><br><span class="line">  webExpressionVoter.setExpressionHandler(handler);</span><br><span class="line"></span><br><span class="line">  List&lt;AccessDecisionVoter&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt;&gt; voters = Arrays.asList(webExpressionVoter);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AffirmativeBased</span>(voters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  http.authorizeRequests()</span><br><span class="line">    .mvcMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/info&quot;</span>, <span class="string">&quot;/account/**&quot;</span>).permitAll()</span><br><span class="line">    .mvcMatchers(<span class="string">&quot;/admin&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">    .mvcMatchers(<span class="string">&quot;/user&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">    .anyRequest().authenticated()</span><br><span class="line">    .accessDecisionManager(accessDecisionManager())</span><br><span class="line">    ;</span><br><span class="line">  http.formLogin();</span><br><span class="line">  http.httpBasic();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래는 AccessDecisionManager를 오버라이딩 하는방식이 아닌 AccessDecisionManager가 사용하는 expressionHandler만 교체해서 사용함 . 더욱 간단해보이지?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SecurityExpressionHandler <span class="title function_">expressionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RoleHierarchyImpl</span> <span class="variable">roleHierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">        roleHierarchy.setHierarchy(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_USER&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DefaultWebSecurityExpressionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityExpressionHandler</span>();</span><br><span class="line">        handler.setRoleHierarchy(roleHierarchy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .mvcMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/info&quot;</span>, <span class="string">&quot;/account/**&quot;</span>).permitAll()</span><br><span class="line">                .mvcMatchers(<span class="string">&quot;/admin&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                .mvcMatchers(<span class="string">&quot;/user&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .expressionHandler(expressionHandler());</span><br><span class="line">        http.formLogin();</span><br><span class="line">        http.httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="FilterSecurityInterceptor-인가-연관"><a href="#FilterSecurityInterceptor-인가-연관" class="headerlink" title="FilterSecurityInterceptor (인가 연관)"></a>FilterSecurityInterceptor (인가 연관)</h3><p>AccessDecisionManager는 도대체 어디서 사용하는것일까? FilterSecurityInterceptor!</p><p>FilterSecurityInterceptor란?<br>AccessDecisionManager를 사용하여 Access Control 또는 예외 처리 하는 필터.<br>FilterChainProxy가 들고있는 여러개의 필터중 하나이며 대부분의 경우 제일 마지막 필터로 들어있다.</p><p>인증이 마지막에 ConfigAttributes를 만족하는지 확인하는 필터가 되겠다.</p><p>FilterSecurityInterceptor의 부모클래스인 AbstractSecurityInterceptor를 보면<br>accessDecisionManager를 활용해서 decision을 한다.<br><strong><code>AbstractSecurityInterceptor.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-ExceptionTranslationFilter-인증-인가-연관"><a href="#19-ExceptionTranslationFilter-인증-인가-연관" class="headerlink" title="19.    ExceptionTranslationFilter (인증,인가 연관)"></a>19.    ExceptionTranslationFilter (인증,인가 연관)</h3><p>FilterSecurityInterceptor에서 발생한 AccessDeniedException과 AuthenticationException을 처리하는 필터<br>(정확히는 FilterSecurityInterceptor 상위클래스인    AbstractSecurityInterceptor 에서 발생한것을 처리)</p><p>AuthenticationException 발생 시<br>●    AuthenticationEntryPoint 실행<br>●    AbstractSecurityInterceptor 하위 클래스(예, FilterSecurityInterceptor)에서 발생하는 예외만 처리.<br>●    그렇다면 UsernamePasswordAuthenticationFilter에서 발생한 인증 에러는? ExceptionTranslationFilter 가 처리하지 않고 UsernamePasswordAuthenticationFilter 상위클래스인 AbstractAuthenticationProcessingFilter에서 처리됨</p><p><strong><code>AbstractAuthenticationProcessingFilter.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line">  <span class="comment">// Authentication failed</span></span><br><span class="line">  unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AccessDeniedException 발생 시<br>●    익명 사용자라면 AuthenticationEntryPoint 실행 - 로그인이 안된 사용자가 admin있는 페이지 접속<br>●    익명 사용자가 아니면 AccessDeniedHandler에게 위임 - 로그인이 된 user 사용자가 admin 페이지 접속</p><p>ExceptionTranslationFilter 생김새는 다음과 같다<br><strong><code>ExceptionTranslationFilter.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AccessDeniedException) &#123;</span><br><span class="line">    <span class="keyword">if</span> (authenticationTrustResolver.isAnonymous(authentication)) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>SecurityContextHolder - Authentication정보를 담고있는 SecurityContextHolder<br>AuthenticationManager(ProviderManager를 보통 많이씀) - 인증(Authentication)은 AuthenticationManager가 한다.<br>AuthenticationProvider - ProviderManager가 리스트로 갖고있음<br>SecurityContextPersisenceFilter - SecurityContext를 HTTP session에 캐시(기본 전략)하여 여러 요청에서 Authentication을 공유할 수 있게하는 필터.<br>UsernamePasswordAuthenticationFilter - 폼 인증을 처리하는 시큐리티 필터&#x2F;인증된 Authentication 객체를 SecurityContextHolder에 넣어주는 필터<br>AbstractAuthenticationProcessingFilter - UsernamePasswordAuthenticationFilter가 상속하는 필터(추상클래스).<br>FilterChainProxy - filterChains를 활용해</p><p>AccessDecisionManager - 인가를 할 땐 AccessDecisionManager 를 쓴다. 여러개의 AccessDecisionVoter(투표자)가 있으며 AccessDecisionManager 구현체로는 최소하나(디폴트), 다수결, 만장일치 가 있다.<br>FilterSecurityInterceptor - AccessDecisionManager는 도대체 어디서 사용하는것일까? FilterSecurityInterceptor!<br>ExceptionTranslationFilter - FilterSecurityInterceptor에서 발생한 AccessDeniedException과 AuthenticationException을 처리하는 필터</p><h3 id="ignoring"><a href="#ignoring" class="headerlink" title="ignoring()"></a>ignoring()</h3><p>시큐리티 설정 중 하나임.</p><p>지금까진 모든 요청은 필터를 활용해왔다.<br>하지만 static 데이터들은 필터들을 적용하고 싶지 않다!(ex 파비콘아이콘)</p><p>스프링 부트가 제공하는 PathRequest를 사용해서 정적 자원 요청을 스프링 시큐리티 필터를 적용하지 않도록 설정.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           web.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래처럼 해도 되지 않나??</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           http.authorizeRequests()</span><br><span class="line">                     .mvcMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                     .mvcMatchers(<span class="string">&quot;/admin&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                     .requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해도 되긴하는데 아래 방식은 추천하지 않음.<br>위의 경우 거치는 필터가 0개지만<br>아래 방식으로 할 경우 15개 필터를 모두 거치게 된다</p><p>특정 리소스에 대해 인증, 인가를 거치고 싶으면 위에서 .exclude()를 활용하면 된다,</p><p>요약<br>이런 설정으로도 같은 결과를 볼 수는 있지만 스프링 시큐리티 필터가 적용된다는 차이가 있다.<br>● 동적 리소스는 http.authorizeRequests()에서 처리하는 것을 권장합니다.<br>● 정적 리소스는 WebSecurity.ignore()를 권장하며 예외적인 정적 자원 (인증이 필요한<br>정적자원이 있는 경우)는 http.authorizeRequests()를 사용할 수 있습니다.</p><h3 id="시큐리티-필터중-최상위-클래스인-WebAsyncManagerIntegrationFilter"><a href="#시큐리티-필터중-최상위-클래스인-WebAsyncManagerIntegrationFilter" class="headerlink" title="시큐리티 필터중 최상위 클래스인 WebAsyncManagerIntegrationFilter"></a>시큐리티 필터중 최상위 클래스인 WebAsyncManagerIntegrationFilter</h3><p>스프링 mvc async handler를 지원하는 핸들러임<br>시큐리티 컨텍스트가 threadlocal을 사용하기 때문에 동일 스레드에서만 시큐리티 컨텍스트를 쓸 수 있는데<br>다른 쓰레드에서도 시큐리티 컨텍스트를 쓸 수 있도록 도와주는 필터가 WebAsyncManagerIntegrationFilter</p><p>스프링 MVC의 Async 기능(핸들러에서 Callable을 리턴할 수 있는 기능)을 사용할 때에도 SecurityContext를 공유하도록 도와주는 필터.</p><p>WebAsyncManagerIntegrationFilter<br>● PreProcess: SecurityContext를 설정한다.<br>● Callable: 비록 다른 쓰레드지만 그 안에서는 동일한 SecurityContext를 참조할 수 있다.<br>● PostProcess: SecurityContext를 정리(clean up)한다.</p><p>아래처럼 코드를 구성했을 때 Callable에 대한 설명<br>           call메소드를 호출하고 리퀘스트를 처리하고 있던 쓰레드를 반환 후 call()이 완료되면 그 때 응답을 보냄. 두페이지로 처리하는것!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/async-handler&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Callalbe&lt;String&gt; <span class="title function_">syncHandler</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt; () &#123;</span><br><span class="line">                     <span class="meta">@Override</span></span><br><span class="line">                     <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래를 돌려보면 쓰레드는 다르지만 Authentication정보는 유지된다.. 이를 WebAsyncManagerIntegrationFilter가 해주는것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/async-handler&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Callalbe&lt;String&gt; <span class="title function_">syncHandler</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">//톰캣이 할당한 NIO 쓰레드 부분</span></span><br><span class="line">          log(<span class="string">&quot;MVC&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt; () &#123;</span><br><span class="line">                     <span class="meta">@Override</span></span><br><span class="line">                     <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                               <span class="comment">//별도의 쓰레드 영역</span></span><br><span class="line">                               SecurityLogger.log(<span class="string">&quot;Callable&quot;</span>);</span><br><span class="line">                               <span class="keyword">return</span> <span class="string">&quot;async handler&quot;</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityLogger</span> &#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">                     System.out.println(message);</span><br><span class="line">                     <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.getCurrentThread();</span><br><span class="line">                     System.out.println(threade.getName());</span><br><span class="line">                     <span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">                     System.out.println(<span class="string">&quot;principal: &quot;</span> + principal);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="스프링-시큐리티와-Async"><a href="#스프링-시큐리티와-Async" class="headerlink" title="스프링 시큐리티와 @Async"></a>스프링 시큐리티와 @Async</h3><blockquote><p>@Async를 사용하기 위해선 @EnableAsync 를 붙여야함(추가로 쓰레드풀 설정을 해줘야 더 올바르게 쓸 수 있다)</p></blockquote><p>@Async를 사용한 서비스를 호출하는 경우<br>● 쓰레드가 다르기 때문에 SecurityContext를 공유받지 못한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMappint(&quot;/async-service&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">asyncService</span><span class="params">()</span> &#123;</span><br><span class="line">          SecurityLogger.log(<span class="string">&quot;MVC, before async service&quot;</span>);</span><br><span class="line">          samplerService.asyncService();</span><br><span class="line">          SecurityLogger.log(<span class="string">&quot;MVC, after async service&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Async Service&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncService</span><span class="params">()</span> &#123;</span><br><span class="line">          SecurityLogger.log(<span class="string">&quot;async Service&quot;</span>); <span class="comment">// NPE 발생</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@Async를 사용하면 서비스 안에서 SecurityContextHolder.getContext().getAuthentication().getPrincipal(); 에서 NPE가 찍히는것을 확인할 수 있다..<br>기본적으로 SecurityContextHolder는 strategy를 선택할 수 있다. 즉 SecurityContextHolder를 어디까지 유지할것인가를 선택할 수 있다(기본은 ThreadLocal. 즉 쓰레드 내)</p><p>아래처럼 설정하면 현재 쓰레드에서 생성하는 하위 쓰레드까지 공유가 된다<br>● SecurityContext를 자식 쓰레드에도 공유하는 전략.<br>● @Async를 처리하는 쓰레드에서도 SecurityContext를 공유받을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proteceted <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurty http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           http.authorizeRequests()</span><br><span class="line">           .mvcMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">           ....</span><br><span class="line"></span><br><span class="line">           SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SecurityContext-영속화-필터-SecurityContextPersistenceFilter"><a href="#SecurityContext-영속화-필터-SecurityContextPersistenceFilter" class="headerlink" title="SecurityContext 영속화 필터: SecurityContextPersistenceFilter"></a>SecurityContext 영속화 필터: SecurityContextPersistenceFilter</h3><p>여러 요청간 시큐리티 콘텍스트를 공유할 수 있게해주는 필터로써 두번째에 위치한다(첫번째는 WebAsyncManagerIntegrationFilter)<br>최초 인증 후 재 리퀘스트를 날려도 인증정보가 유지됨.</p><p>SecurityContextRepository를 사용하는데 SecurityContextRepository의 기본 구현체가 HTTPSessionSecurityContextRepository이다.<br>즉 HTTPSession에서 읽어오는것이다. 처음엔 HTTPSession엔 아무런 정보가 없는데 비어있을 때 비어있는 시큐리티 컨텍스트를 만들때도 SecurityContextPersistenceFilter가 활용이 된다. 기존에 HTTPSesion에 시큐리티 컨텍스트가 저장되어 있는경우에도 가져와 활용한다.<br>그러므로 모든 인증 필터들 보다 위에 있어야 한다. 필터 중 두번째에 위치함</p><p>SecurityContextRepository를 사용해서 기존의 SecurityContext를 읽어오거나 초기화 한다.<br>● 기본으로 사용하는 전략은 HTTP Session을 사용한다.<br>● Spring Session과 연동하여 세션 클러스터를 구현할 수 있다</p><h3 id="시큐리티-관련-헤더-추가하는-필터-HeaderWriterFilter"><a href="#시큐리티-관련-헤더-추가하는-필터-HeaderWriterFilter" class="headerlink" title="시큐리티 관련 헤더 추가하는 필터: HeaderWriterFilter"></a>시큐리티 관련 헤더 추가하는 필터: HeaderWriterFilter</h3><p>직접 신경쓰지 않아도 되는필터임</p><p>응답 헤더에 시큐리티 관련 헤더를 추가해주는 필터로써 세번째 필터임(첫번째는 WebAsyncManagerIntegrationFilter&#x2F; 두번째는 SecurityContextPersistenceFilter &#x2F; 세번째는 HeaderWriterFilter)</p><p>XContentTypeOptionsHeaderWriter: 마임 타입 스니핑 방어.<br>XXssProtectionHeaderWriter: 브라우저에 내장된 XSS 필터 적용.<br>CacheControlHeadersWriter: 캐시 히스토리 취약점 방어.<br>HstsHeaderWriter: HTTPS로만 소통하도록 강제.<br>XFrameOptionsHeaderWriter: clickjacking 방어.</p><p>Cache-Control: no-cache, no-store, max-age&#x3D;0, must-revalidate<br>Content-Language: en-US<br>Content-Type: text&#x2F;html;charset&#x3D;UTF-8<br>Date: Sun, 04 Aug 2019 16:25:10 GMT<br>Expires: 0<br>Pragma: no-cache<br>Transfer-Encoding: chunked<br>X-Content-Type-Options: nosniff<br>X-Frame-Options: DENY<br>X-XSS-Protection: 1; mode&#x3D;block</p><p>기본적으로 다섯개의 HeaderWriter가 적용된다.<br>● XContentTypeOptionsHeaderWriter: 마임 타입 스니핑 방어.<br>브라우저가 마임타입을 판단하려고 컨텐츠를 분석하는 경우가 있다. 그럴 경우 보안상 이슈가 발생할 수 있다.<br>X-Content-Type-Options: nosniff 을 주면 반드시 Content-Type으로만 랜더링 하도록 되어있다. 즉 브라우저가 추가적인 실행을 하지 않기 때문에 보안상 안전하다</p><p>● XXssProtectionHeaderWriter: 브라우저에 내장된 XSS 필터 적용.<br>XSS를 방어해주는것. 브라우저마다 내장된 XSS 필터가 있는데 이 필터로 공격을 방어할 순 없으나 최소한 1차적으로 공격을 걸러낼 수 있다.<br>X-XSS-Protection: 1; mode&#x3D;block 에서 1이 그 기능을 활성화 하는것이고 mode&#x3D;block가 막아준다는 옵션임<br>이걸 켜 놓고 부가적으로 커스텀한 XSS 필터를 적용할 수 있다..</p><p>● CacheControlHeadersWriter: 캐시 히스토리 취약점 방어.<br>Cache-Control: no-cache, no-store, max-age&#x3D;0, must-revalidate<br>Expires: 0<br>Pragma: no-cache<br>위 세개 옵션을 활용해서 캐시를 쓰지 않도록 설정하는것.<br>정적인 리소스는 캐시를 쓰면 좋지만 동적인 리소스는 민감한 정보가 포함되어 있을 수 있기때문에 그런경우에 대한 방어를 하고자 캐시를 비워주는것</p><p>● HstsHeaderWriter: HTTPS로만 소통하도록 강제.<br>Strict-Transport-Security: max-age&#x3D;31536000; includeSubDomains 이런 정보가 샘플로 나간다.</p><p>● XFrameOptionsHeaderWriter: clickjacking 방어.<br>iframe, object, http 그런걸 넣을 수 있는데 보이지 않은 영역에 뭘 누르면 내 정보가 가도록 설정되어 있을 수 있다. 그걸 clickjacking 이라 하는데 이걸 방어하는것으로 아래 헤더정보를 추가한다.<br>X-Frame-Options: DENY</p><h3 id="CSRF-어택-방지-필터-CsrfFilter-네번째-필터"><a href="#CSRF-어택-방지-필터-CsrfFilter-네번째-필터" class="headerlink" title="CSRF 어택 방지 필터: CsrfFilter (네번째 필터)"></a>CSRF 어택 방지 필터: CsrfFilter (네번째 필터)</h3><p>CSRF 어택을 방지하는 필터임<br>Cross site request forgery - 원치않는 요청을 임의로 만들어서 보내는것.<br>인증된 유저의 계정을 사용해 악의적인 변경 요청을 만들어 보내는 기법.<br>은행사이트에 로그인 후 나쁜사이트에 접속했는데 나쁜사이트에서 재밌어 보이는걸 눌렀는데 은행으로 요청을 보냄</p><p>모든 대부분의 요청은 same origin이라 해서 요청하는곳이 일치해야하지만 경우에 따라서 다른 도메인에서의 요청을 허용해야 하는 경우가 있다.<br>이 경우 인증서를 사용하거나 특정 도메인들한테 열어주는것(CORS)가 있다.<br>CORS를 사용할 때 특히 주의 해야 함. 타 도메인에서 보내오는 요청을 허용하기 때문에…</p><p>스프링시큐리티에선 이 경우 CsrfFilter을 활용해서 특정한 토큰(CSRF 토큰)을 활용한다.<br>이를 활용하여 리소스를 변경하는 요청의 경우 서버에서 발급한 토큰이 있는지 확인한다.</p><p>은행이 만들어준 form에는 csrf 토큰이 들어있고 나쁜 사이트가 만들어준 form에는 csrf 토큰이 없기 때문에 은행서버에선 잘못된 요청을 인지할 수 있다.<br>(스프링 시큐리티에서 제공하는 기본 로그인 화면에서도 폼에 csrf가 설정되어있는것을 확인할 수 있다.)<br>restapi에서도 csrf 토큰을 적용할 순 있다. form 기반에선 리소스를 변경하는 요청에는 csrf 토큰을 활용하는것을 추천한다.</p><p>CsrfFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(csrfToken.getToken().equals(actualToken)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>csrf 토큰을 사용하지 않고 싶을 땐 http.csrf().disable(); 를 추가해주면 됨</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proteceted <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurty http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           http.authorizeRequests()</span><br><span class="line">           .mvcMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">           ....</span><br><span class="line"></span><br><span class="line">           http.csrf().disable();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="28-CSRF-토큰-사용-예제"><a href="#28-CSRF-토큰-사용-예제" class="headerlink" title="28.    CSRF 토큰 사용 예제"></a>28.    CSRF 토큰 사용 예제</h3><p>JSP에서 스프링 MVC가 제공하는 <a href="form:form">form:form</a> 태그 또는 타임리프 2.1+ 버전을 사용할 때 폼에 CRSF 히든 필드가 기본으로 생성 됨.<br>get요청인 경우 csrf 토큰 확인안하지만 post 요청인 경우 확인한다<br>포스트맨으로 post로 form으로 로그인 api 호출하면 401이 발생한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignUpControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signUpForm</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/signup&quot;</span>))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andExpect(content().string(containsString(<span class="string">&quot;_csrf&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">procesSignUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(post(<span class="string">&quot;/signup&quot;</span>)</span><br><span class="line">            .param(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;keesun&quot;</span>)</span><br><span class="line">            .param(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">            .with(csrf()))</span><br><span class="line">                .andExpect(status().is3xxRedirection());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="29-로그아웃-처리-필터-LogoutFilter"><a href="#29-로그아웃-처리-필터-LogoutFilter" class="headerlink" title="29.    로그아웃 처리 필터: LogoutFilter"></a>29.    로그아웃 처리 필터: LogoutFilter</h3><p>LogoutHandler, LogoutSuccessHandler가 있다.</p><p>LogoutHandler는 composite 객체로써 다른 여러가지 핸들러를 감싸고 있는 composite타입이여서 사실상 여러개의 핸들러를 사용하고 있는것임<br><strong><code>CompositeLogoutHandler.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CompositeLogoutHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutHandler</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;LogoutHandler&gt; logoutHandlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CompositeLogoutHandler</span><span class="params">(LogoutHandler... logoutHandlers)</span> &#123;</span><br><span class="line">  Assert.notEmpty(logoutHandlers, <span class="string">&quot;LogoutHandlers are required&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.logoutHandlers = Arrays.asList(logoutHandlers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (LogoutHandler handler : <span class="built_in">this</span>.logoutHandlers) &#123;</span><br><span class="line">    handler.logout(request, response, authentication);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LogoutSuccessHandler는 로그아웃을 끝내고 난 후 어떤처리를 할것인지에 대한 핸들러임</p><p>기본으론 SimplUrlLogoutSuccessHandler가 명시되어있는 쪽으로 이동시켜 준다.</p><p>로그아웃 페이지로 가면 로그아웃 창이 뜨는데 이는 DefaultLogoutPageGeneratingFilter가 만들어 준것이다.</p><p>거기서 로그아웃 버튼을 눌렀을 때 (실제로그아웃이 일어났을 때) 로그아웃 필터가 해준다.</p><p><strong><code>LogoutFilter.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (requiresLogout(request, response)) &#123;  <span class="comment">//로그아웃요청만 if문안에 들어감</span></span><br><span class="line">  <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.handler.logout(request, response, auth);</span><br><span class="line">  logoutSuccessHandler.onLogoutSuccess(request, response, auth);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 logout를 호출하면 CompositeLogoutHandler logout로 오게되는데 기본적으로<br>얘는 여러 로그아웃 핸들러를 들고있고(this.logoutHandlers) 우리가 임의로 추가할 수 있다.</p><p>기본적으로는 2개를 들고있는데<br>하나는 CsrfLogoutHandlers이고 하나는 SecurityContextLogoutHandler이다.<br><strong><code>CompositeLogoutHandler.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (LogoutHandler handler : <span class="built_in">this</span>.logoutHandlers) &#123;</span><br><span class="line">handler.logout(request, response, authentication);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logout 후 위에서 logoutSuccessHandler.onLogoutSuccess를 호출하게 되는데 기본적으로 로그인 페이지로 가도록 되어있다.</p><p>근데 얘를 &#x2F; 로 바꾸고 싶으면 아래처럼 하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">http.logout()</span><br><span class="line">        .loginUrl(<span class="string">&quot;/logout&quot;</span>)    <span class="comment">// logout 하는 주소</span></span><br><span class="line">        .logoutSuccessUrl(<span class="string">&quot;/&quot;</span>); <span class="comment">// logout 후 주소</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="폼-인증-처리-필터-UsernamePasswordAuthenticationFilter"><a href="#폼-인증-처리-필터-UsernamePasswordAuthenticationFilter" class="headerlink" title="폼 인증 처리 필터: UsernamePasswordAuthenticationFilter"></a>폼 인증 처리 필터: UsernamePasswordAuthenticationFilter</h3><p>로그인 버튼을 눌렀을 때 이를 처리하는것이 UsernamePasswordAuthenticationFilter<br>UsernamePasswordAuthenticationFilter는 사용자가 폼에 입력한 username과 password로 Authentcation을 만들고<br>AuthenticationManager를 사용하여 인증을 시도한다</p><p>UsernamePasswordAuthenticationFilter 를 보면 UsernamePasswordAuthenticationToken을 만듦. 이후 AuthenticationManager를 활용해 인증을 시도함.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br></pre></td></tr></table></figure><p>AuthenticationManager는 AuthenticationManager의 구현체인 ProviderManager를 사용하는데 ProviderManager는 여러개의 AuthenticationProvider을 갖고있는데 얘한테 위임해서 인증처리를 위임해서 함.<br>AuthenticationProvider 또한 자신이 처리하지 못할경우 부모한테 위임해서 처리를 함.</p><p>AuthenticationProvider 중에서 DaoAuthenticationProvider를 사용하는데 얘는 UserDetailService를 사용하는데 얘가 바로  UserDetailService를 구현한 (우리가만든)놈이다.</p><p>인증이 끝나면 AbstractAuthenticationProcessingFilter(UsernamePasswordAuthenticationFilter 가 상속함) 쪽에서 SecurityContextHolder에다 넣어준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br></pre></td></tr></table></figure><h3 id="DefaultLoginPageGeneratingFilter"><a href="#DefaultLoginPageGeneratingFilter" class="headerlink" title="DefaultLoginPageGeneratingFilter"></a>DefaultLoginPageGeneratingFilter</h3><p>로그인 페이지를 만들어주는 필터<br>get으로 로그인 api에 들어오면 로그인 페이지로 넘겨줌</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">           .loginPage(<span class="string">&quot;/login&quot;</span>)         <span class="comment">//얘를 붙이면 DefaultLoginPageGeneratingFilter, DefaultLogoutPageGeneratingFilter 가 등록이 안됨.(LogoutFilter는 유지됨)</span></span><br><span class="line">                                <span class="comment">// 커스텀한 로그인페이지를 쓴다고 인지하기 때문</span></span><br><span class="line">           .usernameParameter(<span class="string">&quot;my-username&quot;</span>)         <span class="comment">// 파라미터 변경</span></span><br><span class="line">           .passwordParameter(<span class="string">&quot;my-password&quot;</span>);</span><br><span class="line">           .</span><br></pre></td></tr></table></figure><h3 id="로그인-x2F-로그아웃-폼-커스터마이징"><a href="#로그인-x2F-로그아웃-폼-커스터마이징" class="headerlink" title="로그인&#x2F;로그아웃 폼 커스터마이징"></a>로그인&#x2F;로그아웃 폼 커스터마이징</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">           .loginPage(<span class="string">&quot;/signin&quot;</span>)                 </span><br><span class="line">          <span class="comment">// 이 옵션을 추가하면 DefaultLoginPageGeneratingFilter, DefaultLogoutPageGeneratingFilter 가 등록이 안됨.</span></span><br><span class="line">           <span class="comment">// 즉 로그인, 로그아웃 페이지를 만들어줘야함</span></span><br><span class="line">           .permitAll();</span><br></pre></td></tr></table></figure><p>signin 에 get 으로 들어오면 form을 보여주고 post로 들어오면 UsernamePasswordAuthenticationFilter 가 처리한다.</p><p>get으로 들어오는 페이지를 보여주는 컨트롤러만 생성하면 됨. post signin은 UsernamePasswordAuthenticationFilter 가 처리해줌</p><p>위에서 말한대로 loginPage(“&#x2F;signin”) 를 적용하면 Logout 뷰도 사라지기 때문에 새로 만들어줘야한다.</p><h3 id="Basic-인증-처리-필터-BasicAuthenticationFilter"><a href="#Basic-인증-처리-필터-BasicAuthenticationFilter" class="headerlink" title="Basic 인증 처리 필터: BasicAuthenticationFilter"></a>Basic 인증 처리 필터: BasicAuthenticationFilter</h3><p>요청 헤더에 username와 password를 실어 보내면 브라우저 또는 서버가 그 값을 읽어서 인증하는 방식.<br>예)  Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l<br>QWxhZGRpbjpPcGVuU2VzYW1l &lt;- (keesun:123 을 BASE 64인코딩한것)</p><p>보통, 브라우저 기반 요청이 클라이언트의 요청을 처리할 때 자주 사용.<br>● 보안에 취약하기 때문에 반드시 HTTPS를 사용할 것을 권장.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.httpBasic();</span><br></pre></td></tr></table></figure><p>curl -u keesun:123 http:localhost:8080</p><p>BasicAuthenticationFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//form 로그인은 form에서 읽어왔지만 Basic 인증의 경우에는 헤더에서 읽어옴</span></span><br><span class="line"><span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.authenticationConverter.convert(request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (authenticationIsRequired(username)) &#123;</span><br><span class="line">                                          <span class="type">Authentication</span> <span class="variable">authResult</span> <span class="operator">=</span> <span class="built_in">this</span>.authenticationManager.authenticate(authRequest);</span><br><span class="line">                                          <span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">                                          context.setAuthentication(authResult);</span><br><span class="line">                                          SecurityContextHolder.setContext(context);</span><br><span class="line"></span><br><span class="line">                                          <span class="built_in">this</span>.rememberMeServices.loginSuccess(request, response, authResult);          <span class="comment">//이부분 강의시점엔 없는데 추가된듯??</span></span><br><span class="line">                                          <span class="built_in">this</span>.securityContextRepository.saveContext(context, request, response);         <span class="comment">//이부분 강의시점엔 없는데 추가된듯??</span></span><br><span class="line">                                          onSuccessfulAuthentication(request, response, authResult);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>repo 에 저장하는건 없기에 form 로그인처럼 로그인이 유지되진 않는다. 즉 form로그인과 다르게 stateless 함.<br>강의시점엔 로그인이 유지되진 않았으나 인증이 유지되도록 변경된듯 하다.</p><h3 id="요청-캐시-필터-RequestCacheAwareFilter"><a href="#요청-캐시-필터-RequestCacheAwareFilter" class="headerlink" title="요청 캐시 필터: RequestCacheAwareFilter"></a>요청 캐시 필터: RequestCacheAwareFilter</h3><p>현재 요청과 관련 있는 캐시된 요청이 있는지 찾아서 적용하는 필터.<br>● 캐시된 요청이 없다면, 현재 요청 처리<br>● 캐시된 요청이 있다면, 해당 캐시된 요청 처리</p><p>대시보드 페이지로 접속했는데 로그인 페이지로 넘어가게 될 경우 대시보드 요청이 캐시에 저장이 되어있다가 로그인이 완료되면 캐시에 있는걸 꺼내서 대시보드로 연결시켜줌</p><h3 id="시큐리티-관련-서블릿-스팩-구현-필터-SecurityContextHolderAwareRequestFilter"><a href="#시큐리티-관련-서블릿-스팩-구현-필터-SecurityContextHolderAwareRequestFilter" class="headerlink" title="시큐리티 관련 서블릿 스팩 구현 필터: SecurityContextHolderAwareRequestFilter"></a>시큐리티 관련 서블릿 스팩 구현 필터: SecurityContextHolderAwareRequestFilter</h3><p>서블릿3 스펙을 지원하는 일을 함. 그중에서 시큐리티 관련된 스프링 시큐리티 기반으로 구현을 매꿔줌</p><p>HttpServletRequest 클래스 안에 authenticate라는 메소드가 있는데 얘를 호출하면 인증여부를 판단하고 안되어 있으면 로그인페이지로 보냄<br>login메소드는 AuthenticationManager을 활용하서 내부 인증하는것이고<br>logout메소드는 LogoutHandler로 구현이 되어있고<br>AsynContext 의 start메소드도 지원하는데 SecurityContextHolder을 지원하는것임. 새로운 스레드에서도 SecurityContextHolder을 복사하여 사용가능케함</p><p>시큐리티 관련된 서블릿 api를 지원하는것임. 서블릿을 직접 쓸 일 이 있으면 해당 메소드를 쓰면 됨. 뒷단은 결국 스프링 시큐리티 기반으로 동작함</p><h3 id="익명-인증-필터-AnonymousAuthenticationFilter"><a href="#익명-인증-필터-AnonymousAuthenticationFilter" class="headerlink" title="익명 인증 필터: AnonymousAuthenticationFilter"></a>익명 인증 필터: AnonymousAuthenticationFilter</h3><p> 아무도 인증하지 않은 요청일 때 인증이 안된사용자를 AnonymousAuthentication로 만들어 SecurityContextHolder에 넣어준다<br>null object pattern 이라 해서 null 대신에 null을 대변하는 객체를 넣는 패턴임.<br>타 필터를 보면 종종 Anonymous 를 판단해서 분기하는 로직이 종종있다.<br>principal named은 기본적으로 “anonymousUser”이고<br>authority은 기본적으로 “ROLE_ANONYMOUS”.<br>아래코드를 활용할 경우 변경할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.anonymous()</span><br><span class="line">.principal(<span class="string">&quot;auser&quot;</span>)</span><br><span class="line">.authorities(<span class="string">&quot;ROLE_A&quot;</span>)</span><br><span class="line">.key()</span><br></pre></td></tr></table></figure><h3 id="세션-관리-필터-SessionManagementFilter"><a href="#세션-관리-필터-SessionManagementFilter" class="headerlink" title="세션 관리 필터: SessionManagementFilter"></a>세션 관리 필터: SessionManagementFilter</h3><p><code>기능 1. 세션 변조 방지 전략 설정: sessionFixation</code><br>공격자가 웹사이트에 로그인 해서 쿠키를 받아오고 희생자는 공격자의 쿠키로 로그인을 함. 그럼 공격자는 희생자의 정보를 읽어들일 수 있음.<br>해결방법”인증 후 세션 id나 정보를 바꿔 어택커의 쿠키로 희생자의 정보를 볼 수 없도록 함.<br>스프링 시큐리티는 세션변조 방지전략이 서블릿 컨테이너에 따라 달라짐.<br>● none<br>● newSession<br>● migrateSession (서블릿 3.0- 컨테이너 사용시 기본값)<br>● changeSessionId (서브릿 3.1+ 컨테이너 사용시 기본값) - 위에서 말한 세션 id를 바꾸는 전략<br>서블릿 3.0 이하부터 migrateSession전략을 쓰는데 이는 인증이 되었을 때 새로운 세션을 새로 만들고 세션에 있는 정보들을 복사해 오는것임.<br>changeSessionId는 copy과정이 없기에 migrateSession보다 빠름</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManagement()</span><br><span class="line">.newSession() / .migrateSeesion()/ .changeSessionId() / .none()를 선택할 수 있다.</span><br></pre></td></tr></table></figure><p><code>기능 2. 유효하지 않은 세션을 리다이렉트 시킬 URL 설정</code><br>로그아웃했을 때 해당세션은 유효하지 않기 때문에 어디로 보낼지 설정가능함</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManagement().invalidSessionUrl(<span class="string">&quot;/error&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>기능 3. 동시성 제어</code><br>여러 로그인을 막고싶을때 사용함</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManagement()</span><br><span class="line">.maximumSession(<span class="number">1</span>)</span><br><span class="line">.expiredUrl()<span class="comment">// 다중로그인로 인해 만료가 되었을 때 어디로 보낼것인지</span></span><br><span class="line">.maxSessionsPreventsLogin(<span class="literal">true</span>) <span class="comment">// 새로운 세션로그인을 불가능하게 할것이다</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>동시성 제어: maximumSessions<br>● 추가 로그인을 막을지 여부 설정 (기본값, false)</p><p><code>기능 4. 세션생성전략</code><br>아래 4가지가 들어갈 수 있다.<br>● IF_REQUIRED - 기본값. 필요할때 만들어서 사용<br>● NEVER    - 새로 만들진 않지만 있으면 갖다가 쓴다<br>● STATELESS    - 세션이 있더라도 쓰지 않음(캐싱된것도 안쓴다)<br>● ALWAYS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.sessionManagement()</span><br><span class="line">.sessionCreationPolicy(IF_REQUIRED)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>여러개의 서버를 띄울 때 세션을 관리하고자 하면 spring session을 써서 세션 클러스터링을 할 수 있다.</p><h3 id="인증-x2F-인가-예외-처리-필터-ExceptionTranslationFilter"><a href="#인증-x2F-인가-예외-처리-필터-ExceptionTranslationFilter" class="headerlink" title="인증&#x2F;인가 예외 처리 필터: ExceptionTranslationFilter"></a>인증&#x2F;인가 예외 처리 필터: ExceptionTranslationFilter</h3><p>마지막에서 두번째 앞에 위치함<br>마지막 필터인 FilterSecurityInterceptor와 밀접한 관계가 있음<br> ExceptionTranslationFilter가 FilterSecurityInterceptor보다 앞서 위치해서 FilterSecurityInterceptor를 감싸서 실행해야함.<br>FilterSecurityInterceptor의 구현체가 AccessDecisionManager, AffirmativeBased이고 얘네를 활용해서 인가처리를 하는데 이 때 인증관련예외, 인가 관련예외가 발생할 수 있는데 이게 발생하면 ExceptionTranslationFilter는 각 예외에 맞는 처리를 한다.<br>AuthenticationException이 발생하면 ExceptionTranslationFilter가 갖고있는 AuthenticationEntryPoint를 사용하여 예외를 처리함(해당 유저를 인증할 수 있게 인증이 가능한 페이지로 보내는것)<br>AccessDeniedException이 발생하면 ExceptionTranslationFilter가 갖고있는 AccessDeniedHandler를 사용하여 처리를 하는데 기본처리는 403 에러메세지를 보여주는것이다.</p><p>AccessDeniedException을 커스텀한 페이지로 보내고 싶다면 간단하게 아래처럼 하면된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling()</span><br><span class="line">.accessDeniedPage(<span class="string">&quot;/access-denied&quot;</span>);</span><br></pre></td></tr></table></figure><p>서버단에 로그를 남기고 싶다면</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling()</span><br><span class="line">.accessDeniedHandler((request, response, accessDeniedException) -&gt; &#123;</span><br><span class="line">  <span class="type">UserDetails</span> <span class="variable">principal</span> <span class="operator">=</span> (UserDetails) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> principal.getUsername();</span><br><span class="line">  <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">  System.out.println(username + <span class="string">&quot; is denied to access to &quot;</span> + servletPath);</span><br><span class="line">  response.sendRedirect(<span class="string">&quot;/access-denied&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="인가-처리-필터-FilterSecurityInterceptor"><a href="#인가-처리-필터-FilterSecurityInterceptor" class="headerlink" title="인가 처리 필터: FilterSecurityInterceptor"></a>인가 처리 필터: FilterSecurityInterceptor</h3><p>기본적으로 등록하는 필터중 가장 마지막에 있는 필터<br>HTTP 리소스 시큐리티 처리를 담당하는 필터. AccessDecisionManager를 사용하여 인가를 처리한다.</p><p>antPattern()도 지원되고 mvcMatcher() 또는 regexMatcher()도 사용해도 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">.mvcMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/info&quot;</span>, <span class="string">&quot;/account/**&quot;</span>, <span class="string">&quot;/signup&quot;</span>).permitAll()</span><br><span class="line">.mvcMatchers(<span class="string">&quot;/admin&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">.mvcMatchers(<span class="string">&quot;/user&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">.anyRequest().authenticated()<span class="comment">//어떤 권한을 갖던 인증을 하기만 하면 접근가능</span></span><br><span class="line">.anyRequest().fullyAuthenticated() <span class="comment">//이전까진 rememberme로 동작하다 중요한 때 다시 인증을 요청하는것</span></span><br><span class="line">.expressionHandler(expressionHandler());</span><br></pre></td></tr></table></figure><p>hasRole은 hasAuthority의 하위개념임 .hasRole(“USER”) .hasAuthority(“ROLE_USER”) 은 동일하다고 보면 됨<br>마찬가지로 아래코드에서 .roles(account.getRole()) 는 .authorities(“ROLE_”+account.getRole()) 와 같은것임</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> User.builder()</span><br><span class="line">.username(account.getUsername())</span><br><span class="line">.password(account.getPassword())</span><br><span class="line">.roles(account.getRole())</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><p>즉 .roles() 는 prefix로 ROLE_가 붙음</p><h3 id="토큰-기반-인증-필터-RememberMeAuthenticationFilter"><a href="#토큰-기반-인증-필터-RememberMeAuthenticationFilter" class="headerlink" title="토큰 기반 인증 필터 : RememberMeAuthenticationFilter"></a>토큰 기반 인증 필터 : RememberMeAuthenticationFilter</h3><p>로그인할 때 로그인 기억하기 체크박스를 본적 있을것이다. 세션이 종료되거나 만료되어도 세션보다 더 긴 것으로 쿠키나 토큰이 브라우저에 남아있거나 서버 디비에 남아있거나 함.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.rememberMe()</span><br><span class="line">.userDetailsService(accountService)</span><br><span class="line">.tokenValiditySeconds(<span class="number">10</span>) <span class="comment">//기본 2주가 유지됨</span></span><br><span class="line">.useSecureCookie(<span class="literal">true</span>)</span><br><span class="line"> <span class="comment">//https만 쿠키에 접근가능하도록 하는것. https를 적용한다면 true로 해주면 좋다. 쿠키가 노출되면 취약하기에...</span></span><br><span class="line">.key(<span class="string">&quot;remember-me-sample&quot;</span>);</span><br></pre></td></tr></table></figure><p>위를 적용하면 브라우저 내 remember-me-sample 키를 갖는 쿠기가 추가된다.<br>로그인을 하면 jsseionId, remember-me-sample 두개가 있는것을 확인할 수 있고, jsessionId를 지우고 리프레시를 해도 재로그인이 필요없고 jsessionId가 다시 생긴것을 확인할 수 있다.</p><p>jsessionId를 지우고 remember-me-sample만 갖고있는 상황에서 request를 날리면 <code>SecurityContextHolder.getContext().getAuthentication() == null</code> 가 충족하고 rememberMeAuth로 인증을 한다. 인증 후엔 SecurityContextHolder에 넣어준다.</p><p><strong><code>RememberMeAuthenticationFilter.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">rememberMeAuth</span> <span class="operator">=</span> rememberMeServices.autoLogin(request,</span><br><span class="line">        response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rememberMeAuth != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Attempt authenticaton via AuthenticationManager</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        rememberMeAuth = authenticationManager.authenticate(rememberMeAuth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Store to SecurityContextHolder</span></span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(rememberMeAuth);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="커스텀필터-추가하기"><a href="#커스텀필터-추가하기" class="headerlink" title="커스텀필터 추가하기"></a>커스텀필터 추가하기</h3><p>서블릿 필터를 만들어서 활용해도 되고 GenericFilterBean 을 상속받아서 클래스를 만들어도 됨<br>그러면 doFilter()만 오버라이딩 하면 됨</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    stopWatch.start(((HttpServletRequest)request).getRequestURI());</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    logger.info(stopWatch.prettyPrint());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addFilterAfter() 메소드로 어디 뒤에놓을지, addFilterBefroe() 메소드로 어디 앞에놓을지 설정 가능</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAfter(<span class="keyword">new</span> <span class="title class_">LoggingFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure><h3 id="메소드-시큐리티"><a href="#메소드-시큐리티" class="headerlink" title="메소드 시큐리티"></a>메소드 시큐리티</h3><p>웹이아니라 평범한 애플리케이션일 때 활용할 수 있도록 하는것<br>@Secured와 @RollAllowed @PreAuthorize와 @PostAuthorize 를 서비스단의 메소드에 붙이고 서비스 호출 전 Authencation을 만들어 SecurityContextHolder에 넣어서 서비스 메소드 호출가능여부를 판단</p><h3 id="AuthenticationPrincipal"><a href="#AuthenticationPrincipal" class="headerlink" title="@AuthenticationPrincipal"></a>@AuthenticationPrincipal</h3><p>@AuthenticationPrincipal을 활용하면 UserDetailsService 구현체에서 리턴하는 객체를 매개변수로 받을 수 있다.</p><p><strong><code>UserAccount.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAccount</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Account account;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserAccount</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(account.getUsername(), account.getPassword(), List.of(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;ROLE_&quot;</span> + account.getRole())));</span><br><span class="line">    <span class="built_in">this</span>.account = account;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Account <span class="title function_">getAccount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> account;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>UserDetails.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">  <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> accountRepository.findByUsername(username);</span><br><span class="line">  <span class="keyword">if</span> (account == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(username);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserAccount</span>(account);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDetailsService 구현체에서 리턴하는 객체를 매개변수로 받을 수 있다.<br>그 안에 들어있는 Account객체를 getter를 통해 참조할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">xxx</span><span class="params">(Model model, <span class="meta">@AuthenticationPrincipal</span> UserAccount userAccount)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Account를 바로 받을 수 있도록 바꿔보자</p><p>아래처럼 어노테이션을 생성하고</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span></span><br><span class="line"><span class="meta">@AuthenticationPrincipal(expression = &quot;#this == &#x27;anonymousUser&#x27; ? null : account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CurrentUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserAccount안에 있는 account를 꺼낸다는 의미<br>아래처럼 만들어주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">xxx</span><span class="params">(Model model, <span class="meta">@CurrentUser</span> Account account)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2022/03/24/spring-security/when_login.jpg" class="" title="whenLoginFLow">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1부&quot;&gt;&lt;a href=&quot;#1부&quot; class=&quot;headerlink&quot; title=&quot;1부&quot;&gt;&lt;/a&gt;1부&lt;/h2&gt;&lt;p&gt;Principal principal는 아규먼트 리졸버로 받아서 처리된다.&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/categories/Web-App/Spring/"/>
    
    
      <category term="Spring Security" scheme="http://KKimSangHeon.github.io/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>ServerMonitoring</title>
    <link href="http://KKimSangHeon.github.io/2022/02/09/ServerMonitoring/"/>
    <id>http://KKimSangHeon.github.io/2022/02/09/ServerMonitoring/</id>
    <published>2022-02-09T12:19:52.000Z</published>
    <updated>2022-02-09T12:44:45.415Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ServerMonitoring-개발"><a href="#ServerMonitoring-개발" class="headerlink" title="ServerMonitoring 개발"></a>ServerMonitoring 개발</h3><p>한 관리자가 여러 서버를 한눈에 관리할 수 있는 웹 페이지가 있으면 좋겠다고 생각을 했고 djang, vue를 공부해볼겸 진행해본 프로젝트.</p><h4 id="벤치마킹"><a href="#벤치마킹" class="headerlink" title="벤치마킹"></a>벤치마킹</h4><p>다음 항목들을 벤치마킹하여 어떤식으로 활용될 수 있나 참고하였다.<br><code>Ansible</code> <code>Jenifer</code> <code>datadog</code> <code>skwissh</code> <code>netdata</code> <code>munin</code></p><h4 id="사용기술"><a href="#사용기술" class="headerlink" title="사용기술"></a>사용기술</h4><p><code>django (python)</code><br><code>django admin</code><br><code>vue</code><br><code>sqlite3</code><br><code>ORM</code><br><code>WSGI</code><br><code>conda</code><br><code>shell script</code></p><h3 id="설계"><a href="#설계" class="headerlink" title="설계"></a>설계</h3><p>django 서버에서 여러 서버로 ssh로 접속 후 명령어를 질의하고 응답을 가져오는 형태.<br>client는 django 서버로 rest api 을 활용하여 서버의 현 상태를 파악할 수 있는 시스템을 개발하고자 함.</p><p>Server Monitoring &#x2F; Management<br>    - yml 파일 활용하여 서버 구성 추가 및 관리<br>    - Process 모니터링 &#x2F; 특정 Process가 열고있는 포트 확인 &#x2F; 특정 프로세스 kill<br>    - CPU 사용율<br>    - Memory 사용율<br>    - Disk 사용율<br>    - 방화벽 개방여부 확인<br>    - File &#x2F; Directory 조회</p><p>Installation<br>    - UI 상 모듈 install 기능 제공</p><p>Scheduler<br>    - Cron Job 관리<br>    - 즉시실행<br>    - 종료</p><h3 id="ERD"><a href="#ERD" class="headerlink" title="ERD"></a>ERD</h3><img src="/2022/02/09/ServerMonitoring/command.png" class="" title="작동화면"><p>다수 서버 관리라는 특성상 서버의 OS, version에 따라 달라질 수 있는 부분(ex. 명령어)이 있기에 확장성을 고려한 설계를 하고자 하였음<br>CommandType은 어떤 행위를 할 지 추상적인 명칭을 나타내며 Command는 CommandType에 명시된 행위를 실행하기 위한 상세설명의 의미를 갖는다.</p><img src="/2022/02/09/ServerMonitoring/K-000.png" class="" title="서버등록"><p>서버는 위와 같이 Django admin페이지에서 등록 후 활용가능하다.</p><img src="/2022/02/09/ServerMonitoring/ERD.png" class="" title="ERD"><h3 id="기능"><a href="#기능" class="headerlink" title="기능"></a>기능</h3><p>모든 기능은 우측 상된에 선택된 서버 내에서 발생합니다.</p><img src="/2022/02/09/ServerMonitoring/K-001.png" class="" title="설치패키지 조회"><p>설치된 패키지 조회 및 삭제기능</p><img src="/2022/02/09/ServerMonitoring/K-002.png" class="" title="패키지 설치"><p>필요 파일 업로드 후 설치<br>rpm 파일을 업로드할 경우 django서버에 파일이 업로드되고 설치버튼을 누르면 현재 선택된 서버에 설치된다.</p><img src="/2022/02/09/ServerMonitoring/K-003.png" class="" title="CPU사용률"><p>cpu 사용율 조회</p><img src="/2022/02/09/ServerMonitoring/K-004.png" class="" title="memory 조회"><p>memory 조회. top 명령어 기반으로 동작하므로 해당 명령어 실행이 실패할 경우 위와 같이 alert창이 뜬다.</p><img src="/2022/02/09/ServerMonitoring/K-005.png" class="" title="terminal"><p>terminal과 같이 여러 명령어를 입력하여 확인할 수 있다.</p><img src="/2022/02/09/ServerMonitoring/K-006.png" class="" title="firewall"><p>방화벽 오픈여부를 확인한다.</p><img src="/2022/02/09/ServerMonitoring/K-007.png" class="" title="프로세스를 확인"><p>현재 동작중인 프로세스를 확인하며 해당 프로세스가 열고 있는 port 확인, process kill 또한 가능하다.</p><img src="/2022/02/09/ServerMonitoring/K-008.png" class="" title="directory 상세 조회"><p>directory 상세 조회</p><img src="/2022/02/09/ServerMonitoring/K-009.png" class="" title="terminal"><p>위 화면에서 시나리오를 등록할 수 있다.<br>시나리오란 일련의 동작이 정해진 주기마다 돌도록 하는 기능이다.</p><img src="/2022/02/09/ServerMonitoring/K-015.png" class="" title="시나리오 등록"><p>CRON expression, DATE, INTERVAL 을 지원하며 Drag &amp; Drop로 아래와 같이 시나리오를 작성할 수 있다.</p><img src="/2022/02/09/ServerMonitoring/K-011.png" class="" title="Action"><p>스케줄을 생성할 때 세부 동작을 Action이라 한다.<br>시나리오는 한개의 Source, N개의 Destination으로 구성된다.</p><p>Source는 Cpu사용율, file tail, 프로세스 검색이 있으며 Destination 으로는 HTTPGet, Post, SlackNotification을 설정할 수 있다.</p><img src="/2022/02/09/ServerMonitoring/K-013.png" class="" title="Action"><p>다음과 같이 오전 0850분에 SlackNotification이 오도록 설정해 두면 서비스 모니터링도구로써 활용할 수 있다.</p><img src="/2022/02/09/ServerMonitoring/slack.png" class="" title="SlackMessage"><p>위와 같이 지정된 시간에 메세지가 온다.</p><img src="/2022/02/09/ServerMonitoring/K-016.png" class="" title="서버접속로그"><p>ssh를 통한 서버접속 히스토리를 볼 수 있는 화면이다.</p><img src="/2022/02/09/ServerMonitoring/K-017.png" class="" title="ipinfo"><p>ipinfo버튼을 클릭하면 접속한 ip에 대한 자세한 정보를 확인할 수 있다.</p><img src="/2022/02/09/ServerMonitoring/K-018.png" class="" title="접속실패로그"><p>ssh를 통해 접속을 시도했으나 실패한 히스토리이다.</p><img src="/2022/02/09/ServerMonitoring/K-019.png" class="" title="ipinfo"><p>ipinfo버튼을 클릭하면 접속을 시도한 ip에 대한 자세한 정보를 확인할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ServerMonitoring-개발&quot;&gt;&lt;a href=&quot;#ServerMonitoring-개발&quot; class=&quot;headerlink&quot; title=&quot;ServerMonitoring 개발&quot;&gt;&lt;/a&gt;ServerMonitoring 개발&lt;/h3&gt;&lt;p&gt;한 
      
    
    </summary>
    
      <category term="About Me" scheme="http://KKimSangHeon.github.io/categories/About-Me/"/>
    
      <category term="My Projects" scheme="http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"/>
    
    
      <category term="Django" scheme="http://KKimSangHeon.github.io/tags/Django/"/>
    
      <category term="Vuejs" scheme="http://KKimSangHeon.github.io/tags/Vuejs/"/>
    
  </entry>
  
  <entry>
    <title>django model사용시 one to many , many to one 활용</title>
    <link href="http://KKimSangHeon.github.io/2021/03/22/django/"/>
    <id>http://KKimSangHeon.github.io/2021/03/22/django/</id>
    <published>2021-03-22T13:14:10.000Z</published>
    <updated>2022-02-09T11:44:22.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="order-x2F-detail-order가-있을-때"><a href="#order-x2F-detail-order가-있을-때" class="headerlink" title="order &#x2F; detail order가 있을 때"></a>order &#x2F; detail order가 있을 때</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">many to one일때</span><br><span class="line">detail_order = DetailOrder.objects.select_related(&#x27;order&#x27;).get(id=request.data[&#x27;id&#x27;])</span><br><span class="line"></span><br><span class="line">one  to many일땐</span><br><span class="line">order = order.objects.filter(id=1).prefetch_related(&quot;detail_order&quot;)</span><br><span class="line"></span><br><span class="line">remain_detail_order = DetailOrder.objects.filter(order__id=detail_order.order.id).count()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;order-x2F-detail-order가-있을-때&quot;&gt;&lt;a href=&quot;#order-x2F-detail-order가-있을-때&quot; class=&quot;headerlink&quot; title=&quot;order &amp;#x2F; detail order가 있을 때&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Django" scheme="http://KKimSangHeon.github.io/categories/Web-App/Django/"/>
    
    
      <category term="Django" scheme="http://KKimSangHeon.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs EventBus 공통모듈로 사용할 때 모든 페이지가 이벤트를 수신하는 상황</title>
    <link href="http://KKimSangHeon.github.io/2021/03/22/vue/"/>
    <id>http://KKimSangHeon.github.io/2021/03/22/vue/</id>
    <published>2021-03-22T13:04:31.000Z</published>
    <updated>2022-02-09T11:44:22.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="이벤트버스를-공통함수로-빼서-사용할-때의-이슈"><a href="#이벤트버스를-공통함수로-빼서-사용할-때의-이슈" class="headerlink" title="이벤트버스를 공통함수로 빼서 사용할 때의 이슈"></a>이벤트버스를 공통함수로 빼서 사용할 때의 이슈</h3><p>헤더에서 특정값을 변경하면 라우터 뷰에 정의된 페이지도 변경되어야 해서 특정값 변경시 헤더에서 event emit하도록 해놓음…</p><p>이벤트 버스를 공통모듈로 쓰니 해당 이벤트 버스를 쓰는 모든 화면들이 해당 이벤트를 수신하여 난리가남…<br>(SPA라 그런가…. 더 알아볼것.)</p><p>화면이 바뀌면 이벤트를 수신하도록 on 걸어놓은것들은 파괴될줄 알았는데…</p><p>무튼 해결방법은 모든 페이지에 접근할 때마다  created() 내에서 해당 이벤트를 지우고 신규로 등록하도록 하는것.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">    EventBus.$off(&#x27;change-server&#x27;);</span><br><span class="line">    EventBus.$on(&#x27;change-server&#x27;, function() &#123;~~~~&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또는 해당 페이지가 destory 될 때 없애버리기….</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeDestroy()&#123;</span><br><span class="line">    EventBus.$off(&#x27;change-server&#x27;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">created()&#123;</span><br><span class="line">  EventBus.$on(&#x27;change-server&#x27;, function() &#123;~~~~&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;이벤트버스를-공통함수로-빼서-사용할-때의-이슈&quot;&gt;&lt;a href=&quot;#이벤트버스를-공통함수로-빼서-사용할-때의-이슈&quot; class=&quot;headerlink&quot; title=&quot;이벤트버스를 공통함수로 빼서 사용할 때의 이슈&quot;&gt;&lt;/a&gt;이벤트버스를 공통함수
      
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Vuejs" scheme="http://KKimSangHeon.github.io/categories/Web-App/Vuejs/"/>
    
    
      <category term="Web" scheme="http://KKimSangHeon.github.io/tags/Web/"/>
    
      <category term="Vuejs" scheme="http://KKimSangHeon.github.io/tags/Vuejs/"/>
    
  </entry>
  
  <entry>
    <title>django model사용시 queryset의 values 활용</title>
    <link href="http://KKimSangHeon.github.io/2021/02/21/django-model-values/"/>
    <id>http://KKimSangHeon.github.io/2021/02/21/django-model-values/</id>
    <published>2021-02-21T13:08:56.000Z</published>
    <updated>2022-02-09T11:44:22.824Z</updated>
    
    <content type="html"><![CDATA[<p>model을 조회하고 이를 response로 리턴할 때 values를 활용하면 유용함.</p><h3 id="쿼리셋-편하게-리턴하기-values"><a href="#쿼리셋-편하게-리턴하기-values" class="headerlink" title="쿼리셋 편하게 리턴하기 - values()"></a>쿼리셋 편하게 리턴하기 - values()</h3><p>단순히 values() 를 활용할 경우 detail_order 내 외래키로 걸린 object들은 key만 리턴되는데..</p><p>아래의 경우 postnatal_care_man의 username 필드가 필요하여 아래와 같이 처리하였다.</p><p>values() 사용시 <code>__</code>을 잘 사용하면 좋을듯하다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> detail_order_list = DetailOrder.objects.filter(order__customer=finder).values(</span><br><span class="line">  &#x27;id&#x27;,</span><br><span class="line">  &#x27;road_address&#x27;,</span><br><span class="line">  &#x27;detail_address&#x27;,</span><br><span class="line">  &#x27;order_id&#x27;,</span><br><span class="line">  &#x27;start_time&#x27;,</span><br><span class="line">  &#x27;end_time&#x27;,</span><br><span class="line">  &#x27;detail&#x27;,</span><br><span class="line">  &#x27;postnatal_care_man__username&#x27;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Response(detail_order_list.values(), status=status.HTTP_200_OK)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;model을 조회하고 이를 response로 리턴할 때 values를 활용하면 유용함.&lt;/p&gt;
&lt;h3 id=&quot;쿼리셋-편하게-리턴하기-values&quot;&gt;&lt;a href=&quot;#쿼리셋-편하게-리턴하기-values&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Django" scheme="http://KKimSangHeon.github.io/categories/Web-App/Django/"/>
    
    
      <category term="Django" scheme="http://KKimSangHeon.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>django model inner join - orm</title>
    <link href="http://KKimSangHeon.github.io/2021/02/21/django-model-join/"/>
    <id>http://KKimSangHeon.github.io/2021/02/21/django-model-join/</id>
    <published>2021-02-21T13:01:41.000Z</published>
    <updated>2022-02-09T11:44:22.823Z</updated>
    
    <content type="html"><![CDATA[<p>django model의 inner 조인방법</p><p>order, detail_order 이라는 모델이 있을 때</p><h4 id="detail-order을-가져올-때-order내-customer이라는-컬럼을-통해-조인하는-방법"><a href="#detail-order을-가져올-때-order내-customer이라는-컬럼을-통해-조인하는-방법" class="headerlink" title="detail order을 가져올 때 order내 customer이라는 컬럼을 통해 조인하는 방법"></a>detail order을 가져올 때 order내 customer이라는 컬럼을 통해 조인하는 방법</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">detail_order_list = DetailOrder.objects.filter(order__customer=finder)</span><br><span class="line">둘 다 결과 동일</span><br><span class="line">detail_order_list = DetailOrder.objects.select_related(&#x27;order&#x27;).filter(order__customer=finder)</span><br></pre></td></tr></table></figure><p>즉 ‘__’ 를 잘 활용하자…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;django model의 inner 조인방법&lt;/p&gt;
&lt;p&gt;order, detail_order 이라는 모델이 있을 때&lt;/p&gt;
&lt;h4 id=&quot;detail-order을-가져올-때-order내-customer이라는-컬럼을-통해-조인하는-방법&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Django" scheme="http://KKimSangHeon.github.io/categories/Web-App/Django/"/>
    
    
      <category term="Django" scheme="http://KKimSangHeon.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>git hard reset</title>
    <link href="http://KKimSangHeon.github.io/2021/02/21/hardReset/"/>
    <id>http://KKimSangHeon.github.io/2021/02/21/hardReset/</id>
    <published>2021-02-21T12:48:33.000Z</published>
    <updated>2022-02-09T11:44:22.825Z</updated>
    
    <content type="html"><![CDATA[<p>가끔 돌아올수없는 길을 건넜을 때 그냥 돌려버리고 싶을 때….만 활용하자</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line"></span><br><span class="line">돌아가기 원하는 시점의 commit 복사</span><br><span class="line"></span><br><span class="line">$ git reset --hard  &#123;commit ID&#125;</span><br><span class="line"></span><br><span class="line">$ git push -f origin master</span><br></pre></td></tr></table></figure><h4 id="remote-rejected-master-gt-master-pre-receive-hook-declined-발생시"><a href="#remote-rejected-master-gt-master-pre-receive-hook-declined-발생시" class="headerlink" title="! [remote rejected] master -&gt; master (pre-receive hook declined) 발생시"></a>! [remote rejected] master -&gt; master (pre-receive hook declined) 발생시</h4><p>gitlab에서 소스 프로젝트-&gt;세팅-&gt;protected branches에 developer can push라는 체크박스가 있는데 체크 후 unprotect 버튼 클릭 후 재시도</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;가끔 돌아올수없는 길을 건넜을 때 그냥 돌려버리고 싶을 때….만 활용하자&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
      <category term="OS" scheme="http://KKimSangHeon.github.io/categories/OS/"/>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/OS/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>리눅스 서버간 파일 동기화</title>
    <link href="http://KKimSangHeon.github.io/2021/02/21/rsync/"/>
    <id>http://KKimSangHeon.github.io/2021/02/21/rsync/</id>
    <published>2021-02-21T12:32:39.000Z</published>
    <updated>2022-02-09T11:44:22.826Z</updated>
    
    <content type="html"><![CDATA[<p>원격지에 있는 서버에 ftp로 접속하고 파일을 올리지 않고 명령어 한줄로도 가능한 방법이 있음..</p><h3 id="rsync-amp-scp"><a href="#rsync-amp-scp" class="headerlink" title="rsync &amp; scp"></a>rsync &amp; scp</h3><p>원격지에서 데이터를 갖고오기</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz &#123;원격지서버IP&#125;:/postgres/11/postgres</span><br></pre></td></tr></table></figure><p>원격지로 디렉토리 보내기</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r &#123;옮길디렉토리&#125; root@&#123;업로드대상서버IP&#125;:&#123;디렉토리&#125;</span><br></pre></td></tr></table></figure><p>원격지에서 디렉토리 가져오기</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r root@&#123;원격지서버IP&#125;:&#123;디렉토리&#125; &#123;저장할 디렉토리&#125;</span><br></pre></td></tr></table></figure><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p>원격에 있는 파일과 디렉토리를 복사하고 동기화 하기 위해 사용하는 툴.</p><h3 id="rsync-amp-lyncd를-활용한-postgres-서버-동기화"><a href="#rsync-amp-lyncd를-활용한-postgres-서버-동기화" class="headerlink" title="rsync &amp; lyncd를 활용한 postgres 서버 동기화"></a>rsync &amp; lyncd를 활용한 postgres 서버 동기화</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># systemctl enable lsyncd</span><br><span class="line"># systemctl start lsyncd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">서버1</span><br><span class="line">#ssh-keygen</span><br><span class="line">모두 enter</span><br><span class="line"># ssh-copy-id –p 22 root@111.111.111.111</span><br><span class="line"># ssh root@111.111.111.111 ( ssh 접속 확인 )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">서버2</span><br><span class="line">#ssh-keygen</span><br><span class="line">모두 enter</span><br><span class="line"># cat ~/.ssh/id_rsa.pub | ssh –p 22 root@000.000.000.000 “mkdir –p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys”</span><br><span class="line"># ssh root@000.000.000.000. ( ssh 접속 확인 )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">서버1, 서버2</span><br><span class="line"># vi /etc/lsyncd.conf</span><br><span class="line"></span><br><span class="line">settings &#123;</span><br><span class="line">logfile=&quot;/logs/lsyncd.log&quot;,</span><br><span class="line">statusFile=&quot;/logs/lsyncd-status.log&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sync &#123;</span><br><span class="line">default.rsyncssh,# rsync 아님</span><br><span class="line">source=&quot;/data/nas&quot;,</span><br><span class="line">host=&quot;동기화 대상 ip&quot;,</span><br><span class="line">targetdir=&quot;/data/nas&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">systemctl restart lsyncd</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;원격지에 있는 서버에 ftp로 접속하고 파일을 올리지 않고 명령어 한줄로도 가능한 방법이 있음..&lt;/p&gt;
&lt;h3 id=&quot;rsync-amp-scp&quot;&gt;&lt;a href=&quot;#rsync-amp-scp&quot; class=&quot;headerlink&quot; title=&quot;rsyn
      
    
    </summary>
    
      <category term="OS" scheme="http://KKimSangHeon.github.io/categories/OS/"/>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/OS/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue 네아로(네이버아이디)로 로그인 기능 구현</title>
    <link href="http://KKimSangHeon.github.io/2021/01/04/naveroauth/"/>
    <id>http://KKimSangHeon.github.io/2021/01/04/naveroauth/</id>
    <published>2021-01-04T01:42:27.000Z</published>
    <updated>2022-02-09T11:44:22.821Z</updated>
    
    <content type="html"><![CDATA[<p>vue를 활용한 naver 아이디로 로그인 기능 구현</p><h3 id="플로우"><a href="#플로우" class="headerlink" title="플로우"></a>플로우</h3><ol><li>front에서 code를 얻고</li><li>code를 서버로 던지고</li><li>서버에서 code를 활용하여 토큰을 얻고</li><li>얻은 토큰을 통해 사용자 정보를 조회함</li></ol><h3 id="문제사항"><a href="#문제사항" class="headerlink" title="문제사항"></a>문제사항</h3><p>위 1번과정 중 네이버 아이디로 로그인 버튼을 클릭시 axios get함수를 활용하여 코드를 얻으려 하니 CORS 에러가 발생</p><figure class="highlight plaintext"><figcaption><span>Access to XMLHttpRequest at 'https://nid.naver.com/oauth2.0/authorize?response_type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>카카오 아이디로 로그인의 경우 해당 에러가 발생하지 않았는데… 네이버 서버에서 헤더에 CORS관련 세팅을 안해줘서 그렇다고 생각한다.</p><h3 id="해결방법"><a href="#해결방법" class="headerlink" title="해결방법"></a>해결방법</h3><p>해당방법이 적합한 방법인지는 확실하지 않으나 여러 사이트들의 네이버아이디로 로그인에 대해 살펴보니 해당방법으로 처리한것을 확인할 수 있었음.</p><h4 id="해결방법상세"><a href="#해결방법상세" class="headerlink" title="해결방법상세"></a>해결방법상세</h4><p>아래의 주소로 직접 접속하면 리다이렉트도 정상적으로 되고, 코드값도 쿼리파람을 통해 확인할 수 있었음</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://nid.naver.com/oauth2.0/authorize?response_type=code&amp;client_id=XXXXXXXXXXXX&amp;redirect_uri=http%3A%2F%2F127.0.0.1%3A8080%2FnaverLogin&amp;state=78577e6c-3f10-4146-910c-3fd4e684dfb5</span><br></pre></td></tr></table></figure><p>그래서 네이버 아이디로 로그인 버튼 클릭시 axios를 활용하지 않고 위 주소로 페이지 이동을 하도록 처리함.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location.href = authUri</span><br></pre></td></tr></table></figure><p>리다이렉트 된 곳에선 쿼리파람을 통해 얻은 code, state를 서버로 보내도록 함<br>이후 서버에선 <code>https://nid.naver.com/oauth2.0/token</code>을 호출하여 토큰을 얻고 <code>https://openapi.naver.com/v1/nid/me</code> 에 접속해서 사용자 데이터를 얻어옴.</p><p>http get 함수로만 구현되어있는게 약간 독특했던 기억..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vue를 활용한 naver 아이디로 로그인 기능 구현&lt;/p&gt;
&lt;h3 id=&quot;플로우&quot;&gt;&lt;a href=&quot;#플로우&quot; class=&quot;headerlink&quot; title=&quot;플로우&quot;&gt;&lt;/a&gt;플로우&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;front에서 code를 얻고&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="오픈소스,기술" scheme="http://KKimSangHeon.github.io/categories/CS/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%88%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu usb설치시 발생하는 오류 해결방법</title>
    <link href="http://KKimSangHeon.github.io/2020/11/24/linux-1/"/>
    <id>http://KKimSangHeon.github.io/2020/11/24/linux-1/</id>
    <published>2020-11-24T12:28:18.000Z</published>
    <updated>2022-02-09T11:44:22.819Z</updated>
    
    <content type="html"><![CDATA[<p>데스크톱에 usb를 활용하여 우분투를 설치하며 꽤 오랜시간 삽질을 했었는데 gpu와 충돌로 인한 문제였다.</p><p>증상은 설치화면으로 들어가지지 않고 어찌어찌 설치를 완료해도 부팅이 안되는 문제…</p><p>해결방법<br><a href="http://ejklike.github.io/2017/03/05/install-ubuntu-16.04-with-nvidia-gpu.html">http://ejklike.github.io/2017/03/05/install-ubuntu-16.04-with-nvidia-gpu.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;데스크톱에 usb를 활용하여 우분투를 설치하며 꽤 오랜시간 삽질을 했었는데 gpu와 충돌로 인한 문제였다.&lt;/p&gt;
&lt;p&gt;증상은 설치화면으로 들어가지지 않고 어찌어찌 설치를 완료해도 부팅이 안되는 문제…&lt;/p&gt;
&lt;p&gt;해결방법&lt;br&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="OS" scheme="http://KKimSangHeon.github.io/categories/OS/"/>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/OS/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo 포스트 생성 및 배포방법</title>
    <link href="http://KKimSangHeon.github.io/2020/11/24/hexo/"/>
    <id>http://KKimSangHeon.github.io/2020/11/24/hexo/</id>
    <published>2020-11-24T12:20:50.000Z</published>
    <updated>2022-02-09T11:44:22.818Z</updated>
    
    <content type="html"><![CDATA[<h4 id="hexo-설치"><a href="#hexo-설치" class="headerlink" title="hexo 설치"></a>hexo 설치</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h4 id="hexo-포스트-생성"><a href="#hexo-포스트-생성" class="headerlink" title="hexo 포스트 생성"></a>hexo 포스트 생성</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post [postname]</span><br></pre></td></tr></table></figure><h4 id="hexo-배포"><a href="#hexo-배포" class="headerlink" title="hexo 배포"></a>hexo 배포</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g --d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;hexo-설치&quot;&gt;&lt;a href=&quot;#hexo-설치&quot; class=&quot;headerlink&quot; title=&quot;hexo 설치&quot;&gt;&lt;/a&gt;hexo 설치&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="OS" scheme="http://KKimSangHeon.github.io/categories/OS/"/>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/OS/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>로그갱신여부 판단하는 쉘</title>
    <link href="http://KKimSangHeon.github.io/2020/11/24/linux/"/>
    <id>http://KKimSangHeon.github.io/2020/11/24/linux/</id>
    <published>2020-11-24T12:20:34.000Z</published>
    <updated>2022-02-09T11:44:22.820Z</updated>
    
    <content type="html"><![CDATA[<p>서버 내 존재하는 로그파일이 permitIdleSecond이상 아무런 변화가 없을 때 curl을 보내도록 함</p><p>지금은 슬랙 노티를 보내도록 설정해둠</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">idleSecond=0</span><br><span class="line">path=/home/aidxuser/Public/</span><br><span class="line">fileName=nohup_201119.out</span><br><span class="line">#fileName=test.log</span><br><span class="line"></span><br><span class="line">checkIntervalSecond=600</span><br><span class="line">permitIdleSecond=300</span><br><span class="line"></span><br><span class="line">function checkLogCollectiion()</span><br><span class="line">&#123;</span><br><span class="line">        local lastCollected=`date -r $&#123;path&#125;$&#123;fileName&#125; +%s`</span><br><span class="line">        local now=`date +%s`</span><br><span class="line">        idleSecond=`expr $now - $lastCollected`</span><br><span class="line">        #echo $idleSecond</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while true ; do</span><br><span class="line"></span><br><span class="line">        checkLogCollectiion</span><br><span class="line"></span><br><span class="line">        if [ $&#123;idleSecond&#125; -gt $&#123;permitIdleSecond&#125; ]; then</span><br><span class="line">                #echo &quot;Please Check Collection Server&quot;</span><br><span class="line">                curl -s -d &quot;payload=&#123;\&quot;text\&quot;:\&quot;Please Check Collection Server. Idle time : &quot;$&#123;idleSecond&#125;&quot;\&quot;&#125;&quot; &quot;https://hooks.slack.com/services/XXX&quot;</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        sleep $checkIntervalSecond</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;서버 내 존재하는 로그파일이 permitIdleSecond이상 아무런 변화가 없을 때 curl을 보내도록 함&lt;/p&gt;
&lt;p&gt;지금은 슬랙 노티를 보내도록 설정해둠&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="OS" scheme="http://KKimSangHeon.github.io/categories/OS/"/>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/OS/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Kurento</title>
    <link href="http://KKimSangHeon.github.io/2020/09/14/webrtc2/"/>
    <id>http://KKimSangHeon.github.io/2020/09/14/webrtc2/</id>
    <published>2020-09-14T00:31:36.000Z</published>
    <updated>2022-02-09T11:44:22.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="보완예정"><a href="#보완예정" class="headerlink" title="보완예정"></a>보완예정</h3><h3 id="centos-maven-설치"><a href="#centos-maven-설치" class="headerlink" title="centos maven 설치"></a>centos maven 설치</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.navercorp.com/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz  &amp;&amp;</span><br><span class="line">tar xvf apache-maven-3.6.3-bin.tar.gz &amp;&amp;</span><br><span class="line">mv apache-maven-3.6.3 /usr/local/maven &amp;&amp;</span><br><span class="line">ln -s /usr/local/maven/bin/mvn /usr/bin/mvn &amp;&amp;</span><br><span class="line">vi /etc/profile.d/maven.sh</span><br></pre></td></tr></table></figure><p>#!&#x2F;bin&#x2F;bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MAVEN_HOME=/srv/maven</span><br><span class="line">PATH=$MAVEN_HOME/bin:$PATH</span><br><span class="line">export PATH MAVEN_HOME</span><br><span class="line">export CLASSPATH=.</span><br><span class="line"></span><br><span class="line">chmod +x /etc/profile.d/maven.sh</span><br><span class="line">source /etc/profile.d/maven.sh</span><br></pre></td></tr></table></figure><h3 id="Kurento-Media-Server-설치"><a href="#Kurento-Media-Server-설치" class="headerlink" title="Kurento Media Server 설치"></a>Kurento Media Server 설치</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">yum install https://get.pkgs.cloud/release.rpm -y $$</span><br><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=&quot;pkgs.cloud&quot; list available $$</span><br><span class="line">yum install pkgs.cloud-nodejs-7.x-release -y $$</span><br><span class="line"></span><br><span class="line">yum install nodejs-7.x-release -y $$</span><br><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=&quot;pkgs.cloud-nodejs-7.x&quot; list available $$</span><br><span class="line">yum search nodejs $$</span><br><span class="line">yum install nodejs nodejs-devel -y $$</span><br><span class="line"></span><br><span class="line">yum install kurento-release epel-release -y $$</span><br><span class="line"></span><br><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=&quot;pkgs.cloud-kurento&quot; list available $$</span><br><span class="line">yum install kms</span><br><span class="line"></span><br><span class="line">systemctl enable kms.service $$</span><br><span class="line">systemctl start kms.service $$</span><br><span class="line">systemctl restart kms.service $$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --permanent --add-port=49152-65535/udp $$</span><br><span class="line">systemctl reload firewalld</span><br></pre></td></tr></table></figure><h3 id="Kurento-Java-Tutorial"><a href="#Kurento-Java-Tutorial" class="headerlink" title="Kurento Java Tutorial"></a>Kurento Java Tutorial</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install -y git &amp;&amp;</span><br><span class="line">git clone https://github.com/Kurento/kurento-tutorial-java.git &amp;&amp;</span><br><span class="line">cd kurento-tutorial-java/kurento-hello-world &amp;&amp;</span><br><span class="line">git checkout master &amp;&amp;</span><br><span class="line">mvn -U clean spring-boot:run -Dkms.url=ws://localhost:8888/kurento &amp;&amp;</span><br></pre></td></tr></table></figure><h3 id="maven-설치"><a href="#maven-설치" class="headerlink" title="maven 설치"></a>maven 설치</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.navercorp.com/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz  &amp;&amp;</span><br><span class="line">tar xvf apache-maven-3.6.3-bin.tar.gz &amp;&amp;</span><br><span class="line">mv apache-maven-3.6.3 /usr/local/maven &amp;&amp;</span><br><span class="line">ln -s /usr/local/maven/bin/mvn /usr/bin/mvn</span><br></pre></td></tr></table></figure><h3 id="kurento-tutorial-js"><a href="#kurento-tutorial-js" class="headerlink" title="kurento-tutorial-js"></a>kurento-tutorial-js</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$wget https://github.com/Kurento/kurento-tutorial-js.git</span><br><span class="line">$wget https://github.com/Kurento/kurento-tutorial-js/archive/master.zip</span><br><span class="line"></span><br><span class="line">$unzip master.zip</span><br><span class="line">$cd kurento-tutorial-js-master/kurento-hello-world</span><br><span class="line"></span><br><span class="line">#yum install git</span><br><span class="line">$bower install</span><br><span class="line"></span><br><span class="line">sudo npm install -g http-server</span><br><span class="line">http-server -p 8443</span><br></pre></td></tr></table></figure><h3 id="Kurento-Java-Tutorial-1"><a href="#Kurento-Java-Tutorial-1" class="headerlink" title="Kurento Java Tutorial"></a>Kurento Java Tutorial</h3><p>yum install git</p><p>$ git clone <a href="https://github.com/Kurento/kurento-tutorial-java.git">https://github.com/Kurento/kurento-tutorial-java.git</a><br>$ cd kurento-tutorial-java&#x2F;kurento-hello-world<br>$ git checkout master<br>$ mvn -U clean spring-boot:run -Dkms.url&#x3D;ws:&#x2F;&#x2F;localhost:8888&#x2F;kurento</p><h3 id="ssl-인증서-문제로-접속이-안된다"><a href="#ssl-인증서-문제로-접속이-안된다" class="headerlink" title="ssl 인증서 문제로 접속이 안된다."></a>ssl 인증서 문제로 접속이 안된다.</h3><p>yum install openssl</p><p>서버 CA 개인 키 생성.<br>openssl genrsa -des3 -out server.cakey.pem</p><p>서버 CA 공개 키 생성.<br>openssl req -new -x509 -key server.cakey.pem -out root.crt</p><p>서버 개인 키 생성.<br>openssl genrsa -out server.key</p><p>서버 CSR (Certificate Signing Request) 생성.<br>openssl req -new -key server.key -out server.csr</p><p>차체 서명된 인증서 (Self-Signed Certificate) 생성.<br>openssl x509 -req -in server.csr -days 3650 -sha1 -CAcreateserial -CA root.crt -CAkey server.cakey.pem -out server.crt</p><p>참고<br><a href="https://doc-kurento.readthedocs.io/en/stable/tutorials/java/tutorial-helloworld.html">https://doc-kurento.readthedocs.io/en/stable/tutorials/java/tutorial-helloworld.html</a><br>KMS : <a href="https://github.com/pkgs-cloud/kurento">https://github.com/pkgs-cloud/kurento</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;보완예정&quot;&gt;&lt;a href=&quot;#보완예정&quot; class=&quot;headerlink&quot; title=&quot;보완예정&quot;&gt;&lt;/a&gt;보완예정&lt;/h3&gt;&lt;h3 id=&quot;centos-maven-설치&quot;&gt;&lt;a href=&quot;#centos-maven-설치&quot; class=&quot;header
      
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="오픈소스,기술" scheme="http://KKimSangHeon.github.io/categories/CS/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%88%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>webrtc1</title>
    <link href="http://KKimSangHeon.github.io/2020/09/14/webrtc1/"/>
    <id>http://KKimSangHeon.github.io/2020/09/14/webrtc1/</id>
    <published>2020-09-14T00:31:31.000Z</published>
    <updated>2022-02-09T11:44:22.810Z</updated>
    
    <content type="html"><![CDATA[<h3 id="틀린것-많음…-보완할-예정"><a href="#틀린것-많음…-보완할-예정" class="headerlink" title="틀린것 많음… 보완할 예정"></a>틀린것 많음… 보완할 예정</h3><h3 id="알아두어야할-용어설명"><a href="#알아두어야할-용어설명" class="headerlink" title="알아두어야할 용어설명"></a>알아두어야할 용어설명</h3><ul><li><p>Candidate<br>Peer to Peer 통신을 위해 접근할수 있는 경로들의 후보.</p></li><li><p>ICE(Interactive Connectivity Establishment)<br>브라우저가 peer 연결 할 수 있도록 지원하는 프레임워크. ICE는 이러한 작업을 수행하기 위해 STUN과 TURN 서버 둘다 혹은 하나의 서버를 사용.</p></li><li><p>STUN (Session Traversal Utilities for NAT)<br>클라이언트는 인터넷을 통해 클라이언트의 공개주소와 라우터의 NAT 뒤에 있는 클라이언트가 접근가능한지에 대한 답변을 위한 요청을 STUN서버에 보냅니다. 즉 자신의 공인 IP를 STUN에 요청하고 이후 통신시도함.<br>STUN의 경우에는 구글의 오픈서버를 사용하면 됨</p></li><li><p>TURN (Traversal Using Relays around NAT )<br>STUN을 통했으나 Peer을 서로 못찾았을 때 이를 활용한다. 이 방식은 TURN 서버를 통해 서로 통신하므로 (Proxy를 생각하면 좋다)비용이 많이든다.<br>외부에 있는 사람들과 화상 통화를 하려면 TURN 서버가 필수적인데 미디어와 영상이 해당 서버를 통해 거쳐간다(proxy를 생각하자).<br>TURN 서버와 연결을 한 후 모든 peer들에게 저 서버에 모든 패킷을 보내고 다시 나에게 전달해달라고 해야 합니다. 이것은 명백히 오버헤드가 발생하므로 이 방법은 다른 대안이 없을 경우만 사용하게 됨.<br>서버 부하가 많으므로 무료로 제공하는곳을 찾기힘듦</p></li><li><p>SDP (Session Description Protocol )<br>해상도나 형식, 코덱, 암호화등의 멀티미디어 컨텐츠의 연결을 설명하기 위한 표준입니다.</p></li><li><p>Signaling<br>WebRTC는 P2P 통신이지만 이를 중계하는 서버가 필요한데 이를 시그널 서버라 한다. 중계라 하면 연결을 위한 데이터(SDP, Candidtate) 요청 등…WebRTC에서 제공하는것은 아님</p></li></ul><p><a href="https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API/Protocols">https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API/Protocols</a> 그림넣기</p><h4 id="채널생성"><a href="#채널생성" class="headerlink" title="채널생성"></a>채널생성</h4><p>Channel API를 통해 채널을 생성하는 방식은 다음과 같습니다<br>클라이언트 A가 하나의 유니크 ID를 생성합니다.<br>클라이언트 A는 자신의 ID를 App Engine 앱에 넘겨주면서 채널 토큰을 요청합니다.<br>App Engine 앱은 Channel API로 부터 채널과 클라이언트 ID에 해당하는 토큰을 요청합니다.<br>앱은 토큰을 클라이언트 A에게 전달합니다.<br>클라이언트 A는 소켓을 열고 서버에 설정된 채널로부터 메세지를 기다립니다.</p><h4 id="메세지-전송"><a href="#메세지-전송" class="headerlink" title="메세지 전송"></a>메세지 전송</h4><p>클라이언트 B는 변경사항과 함께 App Engine 앱으로 POST 요청을 보냅니다.<br>App Engine 앱은 요청을 channel을 통해 전달합니다.<br>채널은 메세지를 클라이언트 A에게 전달합니다.<br>클라이언트 A의 onmessage 콜백함수가 호출됩니다.</p><h3 id="WebRTC의-제공-API"><a href="#WebRTC의-제공-API" class="headerlink" title="WebRTC의 제공 API"></a>WebRTC의 제공 API</h3><p>1.MediaStream: 사용자의 카메라와 마이크 같은 곳의 데이터 스트림에 접근합니다. 이를 PeerConnection에 전달하여 미디어를 전송함<br>2.RTCPeerConnection: 암호화 및 대역폭 관리를 하는 기능을 가지고 있고, 오디오 또는 비디오 교환을 합니다.<br>3.RTCDataChannel: 데이터 통신을 지원하는 채널.</p><h3 id="1-MediaStream"><a href="#1-MediaStream" class="headerlink" title="1.MediaStream"></a>1.MediaStream</h3><p><a href="https://simpl.info/getusermedia/">https://simpl.info/getusermedia/</a> 에 들어가서 소스코드를 분석해보자.</p><p>getUserMedia() 함수는 아래와 같이 세개의 요소가 필요</p><ul><li>constraints</li><li>에러핸들링 함수</li><li>성공했을 때 함수</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var constraints = &#123;</span><br><span class="line">  video: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function handleSuccess(stream) &#123;</span><br><span class="line">  window.stream = stream; // only to make stream available to console</span><br><span class="line">  video.srcObject = stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleError(error) &#123;</span><br><span class="line">  console.log(&#x27;getUserMedia error: &#x27;, error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">navigator.mediaDevices.getUserMedia(constraints).</span><br><span class="line">  then(handleSuccess).catch(handleError);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-RTCPeerConnection"><a href="#2-RTCPeerConnection" class="headerlink" title="2.RTCPeerConnection"></a>2.RTCPeerConnection</h3><h4 id="먼저-Signaling-이란-session-control-network-and-media-information"><a href="#먼저-Signaling-이란-session-control-network-and-media-information" class="headerlink" title="먼저 Signaling 이란: session control, network and media information"></a>먼저 Signaling 이란: session control, network and media information</h4><p>RTCPeerConnection을 위해 Signaling으로 알려진 일련의 과정이 필요하다.</p><p>Signaling 메세지의 요소들은 다음과 같다.</p><ul><li>Session control messages: 통신의 초기화, 종료 그리고 에러 리포트 정보</li><li>Network configuration: 내 컴퓨터의 IP 주소와 Port 정보</li><li>Media capabilities: 내 브라우저와 상대브라우저가 사용 가능한 코덱들과 해상도 정보<br>이 시그널링 프로세스는 클라이언트에서 메세지를 송신하는 방법을 필요로 합니다. 그 메커니즘은 WebRTC API에 의해 구현되지 않습니다<br>시그널링을 위해 오가는 데이터는 SDP(Session Description Protocol) 형태이다.<br>시그널링 간 오가는 데이터는 ice 서버에서 얻어온다.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var signalingChannel = createSignalingChannel();</span><br><span class="line">var pc;</span><br><span class="line">var configuration = ...;</span><br><span class="line"></span><br><span class="line">// run start(true) to initiate a call</span><br><span class="line">function start(isCaller) &#123;</span><br><span class="line">    pc = new RTCPeerConnection(configuration);</span><br><span class="line"></span><br><span class="line">    // send any ice candidates to the other peer</span><br><span class="line">    pc.onicecandidate = function (evt) &#123;</span><br><span class="line">        signalingChannel.send(JSON.stringify(&#123; &quot;candidate&quot;: evt.candidate &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // once remote stream arrives, show it in the remote video element</span><br><span class="line">    pc.onaddstream = function (evt) &#123;</span><br><span class="line">        remoteView.src = URL.createObjectURL(evt.stream);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // get the local stream, show it in the local video element and send it</span><br><span class="line">    navigator.getUserMedia(&#123; &quot;audio&quot;: true, &quot;video&quot;: true &#125;, function (stream) &#123;</span><br><span class="line">        selfView.src = URL.createObjectURL(stream);</span><br><span class="line">        pc.addStream(stream);</span><br><span class="line"></span><br><span class="line">        if (isCaller)</span><br><span class="line">            pc.createOffer(gotDescription);</span><br><span class="line">        else</span><br><span class="line">            pc.createAnswer(pc.remoteDescription, gotDescription);</span><br><span class="line"></span><br><span class="line">        function gotDescription(desc) &#123;</span><br><span class="line">            pc.setLocalDescription(desc);</span><br><span class="line">            signalingChannel.send(JSON.stringify(&#123; &quot;sdp&quot;: desc &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signalingChannel.onmessage = function (evt) &#123;</span><br><span class="line">    if (!pc)</span><br><span class="line">        start(false);</span><br><span class="line"></span><br><span class="line">    var signal = JSON.parse(evt.data);</span><br><span class="line">    if (signal.sdp)</span><br><span class="line">        pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));</span><br><span class="line">    else</span><br><span class="line">        pc.addIceCandidate(new RTCIceCandidate(signal.candidate));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-RTCDataChannel"><a href="#3-RTCDataChannel" class="headerlink" title="3.RTCDataChannel"></a>3.RTCDataChannel</h3><p>오디오와 비디오처럼, WebRTC는 실시간으로 다른 형태의 데이터 통신도 지원</p><h3 id="헷갈리는-부분…"><a href="#헷갈리는-부분…" class="headerlink" title="헷갈리는 부분…"></a>헷갈리는 부분…</h3><p>시그널링을 위한 서버는 필요함.<br>시그널링서버와 STUN, TURN서버는 다른개념. 즉 따로존재해야함<br>Peer-to-Peer 통신을 위해서는 브라우저 간 통신 가능<br>그룹 커뮤니케이션을 위해서는 미디어 서버가 필요함.(ex Janus Gateway &#x2F; kurento- signaling 미지원)</p><p>릴레이서버??? p2p 커뮤니케이션 통신이 실패하면 turn 서버를 활용한 통신한다. &#x3D;&#x3D; TURN 서버</p><p>미디어서버(MCU&#x2F;SFU) :</p><p>#MCU(Multipoint Control Unit)란?<br>-다대다 통신에서 미디어 서버는 여러 미디어 스트림을 하나의 스트림으로 만든 후 클라이언트에게 제공합니다.<br>-서버의 CPU 부하가 SFU에 비해 높은 편이지만, 사용자는 SFU에 비해 더 적은량의 데이터로 미디어 스트림을 받을 수 있습니다.</p><p>#SFU(Selective Forwarding Unit)란?<br>-다대다 통신에서 미디어 서버는 여러 미디어 스트림을 하나로 만들기 위한 디코딩, 인코딩 작업 없이 클라이언트에게 제공합니다.<br>-서버의 CPU부하가 MCU에 비해 낮은 편이지만, 사용자는 MCU에 비해 더 많은량의 데이터를 수신해야 합니다.</p><p>일대일&#x2F;일대 다일때 TURN 통신<br>브라우저가 시그널링 서버에 접근하면 시그널링 서버는 TURN의 채널을 열게된다.<br>일대 다일땐 브라우저가 TURN채널에 전송하고 TURN은 다시 미디어서버로 전송한다.</p><p>브라우저-TURN을 통해 미디어 서버 주소 알아옴-미디어서버-TURN을 통해 원격 주소 알아옴-브라우저<br>TURN 안쓸때 브라우저-STUN을 통해 미디어서버 주소를 알아옴-미디어서버-STUN을 통해 원격주소 알아오고 -브라우저???</p><p>시그널 서버가 미디어서버와 통신하는 턴 채널을 생성.</p><p>STUN은 일대일 용도(완벽하지않지만 이렇게 생각이 편함)<br>TURN은 일대 다</p><p><a href="https://cryingnavi.github.io/WebRTC-Basic/">https://cryingnavi.github.io/WebRTC-Basic/</a><br><a href="https://www.dinobot.info/95">https://www.dinobot.info/95</a></p><p><a href="https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API/Protocols">https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API/Protocols</a></p><p><a href="https://www.html5rocks.com/ko/tutorials/webrtc/basics/#toc-mediastream">https://www.html5rocks.com/ko/tutorials/webrtc/basics/#toc-mediastream</a><br><a href="https://www.html5rocks.com/ko/tutorials/webrtc/infrastructure/">https://www.html5rocks.com/ko/tutorials/webrtc/infrastructure/</a></p><p><a href="https://m.blog.naver.com/PostView.nhn?blogId=djjproject&amp;logNo=220896510901&amp;proxyReferer=http://59.29.251.41/tm/?a=CR&b=WIN&c=300023095277&d=32&e=5206&f=bS5ibG9nLm5hdmVyLmNvbS9kampwcm9qZWN0LzIyMDg5NjUxMDkwMQ==&g=1591597231415&h=1591597230428&y=0&z=0&x=1&w=2020-02-18&in=5206_1520_00016662&id=20200608">https://m.blog.naver.com/PostView.nhn?blogId=djjproject&amp;logNo=220896510901&amp;proxyReferer=http:%2F%2F59.29.251.41%2Ftm%2F%3Fa%3DCR%26b%3DWIN%26c%3D300023095277%26d%3D32%26e%3D5206%26f%3DbS5ibG9nLm5hdmVyLmNvbS9kampwcm9qZWN0LzIyMDg5NjUxMDkwMQ%3D%3D%26g%3D1591597231415%26h%3D1591597230428%26y%3D0%26z%3D0%26x%3D1%26w%3D2020-02-18%26in%3D5206_1520_00016662%26id%3D20200608</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;틀린것-많음…-보완할-예정&quot;&gt;&lt;a href=&quot;#틀린것-많음…-보완할-예정&quot; class=&quot;headerlink&quot; title=&quot;틀린것 많음… 보완할 예정&quot;&gt;&lt;/a&gt;틀린것 많음… 보완할 예정&lt;/h3&gt;&lt;h3 id=&quot;알아두어야할-용어설명&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="오픈소스,기술" scheme="http://KKimSangHeon.github.io/categories/CS/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%88%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx 활용하여 udp 패킷 포트포워딩</title>
    <link href="http://KKimSangHeon.github.io/2020/09/14/nginx/"/>
    <id>http://KKimSangHeon.github.io/2020/09/14/nginx/</id>
    <published>2020-09-14T00:21:43.000Z</published>
    <updated>2022-02-09T11:44:22.809Z</updated>
    
    <content type="html"><![CDATA[<p>wget <a href="http://nginx.org/packages/centos/6/x86_64/RPMS/nginx-1.16.0-1.el6.ngx.x86_64.rpm">http://nginx.org/packages/centos/6/x86_64/RPMS/nginx-1.16.0-1.el6.ngx.x86_64.rpm</a></p><p>rpm -ivh nginx-1.16.0-1.el6.ngx.x86_64.rpm</p><p>vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><p>stream {<br>    server {<br>    listen 1234 udp;<br>    proxy_pass proxy_udp;<br>    }</p><pre><code>upstream proxy_udp &#123;</code></pre><p>  server xxx.xxx.xxx.xxx:5678;<br>    }<br>}</p><p>service nginx restart</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;wget &lt;a href=&quot;http://nginx.org/packages/centos/6/x86_64/RPMS/nginx-1.16.0-1.el6.ngx.x86_64.rpm&quot;&gt;http://nginx.org/packages/centos/6/x86_64
      
    
    </summary>
    
      <category term="OS" scheme="http://KKimSangHeon.github.io/categories/OS/"/>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/OS/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ipvsadm 으로 udp proxy, load balance 구현</title>
    <link href="http://KKimSangHeon.github.io/2020/05/11/linux4/"/>
    <id>http://KKimSangHeon.github.io/2020/05/11/linux4/</id>
    <published>2020-05-11T12:14:38.000Z</published>
    <updated>2022-02-09T11:44:22.808Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Load-Balancer-Server-설정"><a href="#Load-Balancer-Server-설정" class="headerlink" title="Load Balancer Server 설정"></a>Load Balancer Server 설정</h3><p>설치</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ipvsadm</span><br></pre></td></tr></table></figure><p>&#x2F;etc&#x2F;sysctl.conf 에 아래 입력</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><p>적용</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p#적용</span><br><span class="line">touch /etc/sysconfig/ipvsadm   # 얘가 뭐하는애지 a모르것지만 해야지 켜진다.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chkconfig ipvsadm on</span><br><span class="line">chkconfig --level 345 ipvsadm on</span><br><span class="line"></span><br><span class="line">systemctl start ipvsadm//시작  </span><br><span class="line">systemctl enable ipvsadm.service//상시가동</span><br><span class="line">systemctl status ipvsadm.service</span><br></pre></td></tr></table></figure><p>가상아이피 등록</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0:0 192.168.100.102 up</span><br><span class="line"></span><br><span class="line">ipvsadm -A -u 192.168.100.102:9131  # A:add virtual service with options  u:udp-service</span><br><span class="line">ipvsadm -a -u 192.168.100.102:9131 -r  192.168.100.198:9131 -m    # r:real-server   m:masquerading</span><br></pre></td></tr></table></figure><p>-m 대신 -g는 NAT 방식이냐, Direct Routing 방식이냐에 따른 차이<br>Direct Routing의 경우 수신한 서버에서 User에게 response를 직접 전달한다.<br>NAT 방식은 NAT 서버를 통해 User에게 response를 한다.</p><h3 id="Real-Server-받는쪽-설정"><a href="#Real-Server-받는쪽-설정" class="headerlink" title="Real Server(받는쪽) 설정"></a>Real Server(받는쪽) 설정</h3><p>&#x2F;etc&#x2F;sysctl.conf에 아래 추가</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.lo.arp_ignore = 1</span><br><span class="line">net.ipv4.conf.lo.arp_announce = 2</span><br><span class="line">net.ipv4.conf.all.arp_ignore = 1</span><br><span class="line">net.ipv4.conf.all.arp_announce = 2</span><br></pre></td></tr></table></figure><p>커널파라미터 적용</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -p</span><br></pre></td></tr></table></figure><p>가상아이피 등록</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth0:0 192.168.100.102 up# direct 방식일 경우에만 사용됨. 이부분 잊지말자 !!</span><br></pre></td></tr></table></figure><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p>실시간 분배 확인하기</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch ipvsadm -ln</span><br></pre></td></tr></table></figure><p>서비스 초기화</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -C</span><br></pre></td></tr></table></figure><p>서비스 상태조회</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -L --stats</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm v1.27 2008/5/15 (compiled with popt and IPVS v1.2.1)</span><br><span class="line">Usage:</span><br><span class="line">  ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] [-M netmask] [--pe persistence_engine] [-b sched-flags]</span><br><span class="line">  ipvsadm -D -t|u|f service-address</span><br><span class="line">  ipvsadm -C</span><br><span class="line">  ipvsadm -R</span><br><span class="line">  ipvsadm -S [-n]</span><br><span class="line">  ipvsadm -a|e -t|u|f service-address -r server-address [options]</span><br><span class="line">  ipvsadm -d -t|u|f service-address -r server-address</span><br><span class="line">  ipvsadm -L|l [options]</span><br><span class="line">  ipvsadm -Z [-t|u|f service-address]</span><br><span class="line">  ipvsadm --set tcp tcpfin udp</span><br><span class="line">  ipvsadm --start-daemon state [--mcast-interface interface] [--syncid sid]</span><br><span class="line">  ipvsadm --stop-daemon state</span><br><span class="line">  ipvsadm -h</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">Either long or short options are allowed.</span><br><span class="line">  --add-service     -A        add virtual service with options</span><br><span class="line">  --edit-service    -E        edit virtual service with options</span><br><span class="line">  --delete-service  -D        delete virtual service</span><br><span class="line">  --clear           -C        clear the whole table</span><br><span class="line">  --restore         -R        restore rules from stdin</span><br><span class="line">  --save            -S        save rules to stdout</span><br><span class="line">  --add-server      -a        add real server with options</span><br><span class="line">  --edit-server     -e        edit real server with options</span><br><span class="line">  --delete-server   -d        delete real server</span><br><span class="line">  --list            -L|-l     list the table</span><br><span class="line">  --zero            -Z        zero counters in a service or all services</span><br><span class="line">  --set tcp tcpfin udp        set connection timeout values</span><br><span class="line">  --start-daemon              start connection sync daemon</span><br><span class="line">  --stop-daemon               stop connection sync daemon</span><br><span class="line">  --help            -h        display this help message</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --tcp-service  -t service-address   service-address is host[:port]</span><br><span class="line">  --udp-service  -u service-address   service-address is host[:port]</span><br><span class="line">  --fwmark-service  -f fwmark         fwmark is an integer greater than zero</span><br><span class="line">  --ipv6         -6                   fwmark entry uses IPv6</span><br><span class="line">  --scheduler    -s scheduler         one of rr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq,</span><br><span class="line">                                      the default scheduler is wlc.</span><br><span class="line">  --pe            engine              alternate persistence engine may be sip,</span><br><span class="line">                                      not set by default.</span><br><span class="line">  --persistent   -p [timeout]         persistent service</span><br><span class="line">  --netmask      -M netmask           persistent granularity mask</span><br><span class="line">  --real-server  -r server-address    server-address is host (and port)</span><br><span class="line">  --gatewaying   -g                   gatewaying (direct routing) (default)</span><br><span class="line">  --ipip         -i                   ipip encapsulation (tunneling)</span><br><span class="line">  --masquerading -m                   masquerading (NAT)</span><br><span class="line">  --weight       -w weight            capacity of real server</span><br><span class="line">  --u-threshold  -x uthreshold        upper threshold of connections</span><br><span class="line">  --l-threshold  -y lthreshold        lower threshold of connections</span><br><span class="line">  --mcast-interface interface         multicast interface for connection sync</span><br><span class="line">  --syncid sid                        syncid for connection sync (default=255)</span><br><span class="line">  --connection   -c                   output of current IPVS connections</span><br><span class="line">  --timeout                           output of timeout (tcp tcpfin udp)</span><br><span class="line">  --daemon                            output of daemon information</span><br><span class="line">  --stats                             output of statistics information</span><br><span class="line">  --rate                              output of rate information</span><br><span class="line">  --exact                             expand numbers (display exact values)</span><br><span class="line">  --thresholds                        output of thresholds information</span><br><span class="line">  --persistent-conn                   output of persistent connection info</span><br><span class="line">  --nosort                            disable sorting output of service/server entries</span><br><span class="line">  --sort                              does nothing, for backwards compatibility</span><br><span class="line">  --ops          -o                   one-packet scheduling</span><br><span class="line">  --numeric      -n                   numeric output of addresses and ports</span><br><span class="line">  --sched-flags  -b flags             scheduler flags (comma-separated)</span><br></pre></td></tr></table></figure><p>참고 : <a href="https://www.linux.co.kr/home/lecture/index.php?cateNo=1&amp;secNo=152&amp;theNo=&amp;leccode=10904">https://www.linux.co.kr/home/lecture/index.php?cateNo=1&amp;secNo=152&amp;theNo=&amp;leccode=10904</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Load-Balancer-Server-설정&quot;&gt;&lt;a href=&quot;#Load-Balancer-Server-설정&quot; class=&quot;headerlink&quot; title=&quot;Load Balancer Server 설정&quot;&gt;&lt;/a&gt;Load Balancer Ser
      
    
    </summary>
    
      <category term="OS" scheme="http://KKimSangHeon.github.io/categories/OS/"/>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/OS/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos FTP(vsftpd) 설치</title>
    <link href="http://KKimSangHeon.github.io/2020/05/11/linux3/"/>
    <id>http://KKimSangHeon.github.io/2020/05/11/linux3/</id>
    <published>2020-05-11T12:14:32.000Z</published>
    <updated>2022-02-09T11:44:22.807Z</updated>
    
    <content type="html"><![CDATA[<p>yum install vsftpd   &#x2F;&#x2F;165kb 밖에 안되는데 성능이 좋다!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/vsftpd/vsftpd.conf</span><br><span class="line">29행 어나니머스가 업로드하는것을 허락한다. 주석해제</span><br><span class="line">33행 어나니머스가 디렉토리를 만드는것을 허락한다. 주석해제</span><br><span class="line"></span><br><span class="line">systemctl restart vsftpd</span><br><span class="line">yum install firewalld</span><br><span class="line">systemctl start firewalld</span><br><span class="line">systemctl enable firewalld</span><br><span class="line">ifconfig</span><br><span class="line">firewall-cmd --zone=public --permanent --add-port=21/tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>참고 : <a href="https://kkimsangheon.github.io/2017/07/15/ThisIsLinux36/">https://kkimsangheon.github.io/2017/07/15/ThisIsLinux36/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;yum install vsftpd   &amp;#x2F;&amp;#x2F;165kb 밖에 안되는데 성능이 좋다!&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="OS" scheme="http://KKimSangHeon.github.io/categories/OS/"/>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/OS/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos 개방 포트 확인</title>
    <link href="http://KKimSangHeon.github.io/2020/05/11/linux2/"/>
    <id>http://KKimSangHeon.github.io/2020/05/11/linux2/</id>
    <published>2020-05-11T12:08:35.000Z</published>
    <updated>2022-02-09T11:44:22.806Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP-포트확인"><a href="#TCP-포트확인" class="headerlink" title="TCP 포트확인"></a>TCP 포트확인</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nc -z -v 127.0.0.1 22</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">telnet 127.0.0.1 22</span><br></pre></td></tr></table></figure><h3 id="UDP-포트-확인"><a href="#UDP-포트-확인" class="headerlink" title="UDP 포트 확인"></a>UDP 포트 확인</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -z -v -u 127.0.0.1 22</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP-포트확인&quot;&gt;&lt;a href=&quot;#TCP-포트확인&quot; class=&quot;headerlink&quot; title=&quot;TCP 포트확인&quot;&gt;&lt;/a&gt;TCP 포트확인&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="OS" scheme="http://KKimSangHeon.github.io/categories/OS/"/>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/OS/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos tcp,udp 패킷덤프</title>
    <link href="http://KKimSangHeon.github.io/2020/05/11/linux1/"/>
    <id>http://KKimSangHeon.github.io/2020/05/11/linux1/</id>
    <published>2020-05-11T12:08:24.000Z</published>
    <updated>2022-02-09T11:44:22.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="udp-덤프"><a href="#udp-덤프" class="headerlink" title="udp 덤프"></a>udp 덤프</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 port 9129 -w packet.dump</span><br><span class="line">tcpdump udp -i eth1 port 9129 -w packet.dump</span><br></pre></td></tr></table></figure><h3 id="덤프-후-확인"><a href="#덤프-후-확인" class="headerlink" title="덤프 후 확인"></a>덤프 후 확인</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -Xqnr packet.dump</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;udp-덤프&quot;&gt;&lt;a href=&quot;#udp-덤프&quot; class=&quot;headerlink&quot; title=&quot;udp 덤프&quot;&gt;&lt;/a&gt;udp 덤프&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="OS" scheme="http://KKimSangHeon.github.io/categories/OS/"/>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/OS/Linux/"/>
    
    
  </entry>
  
</feed>
